#+TITLE: Emacs Configuration
#+ORIGNAL:Harry R. Schwartz
#+AUTHOR: MattLu
#+EMAIL: lu.man@outlook.com
#+OPTIONS: toc:nil num:nil
[[https://github.com/hrs/dotfiles][Harry R. Schwartz]]
* Configure =use-package=

#+BEGIN_SRC emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-verbose t)
  (setq use-package-always-ensure t)
#+END_SRC

use auto-package-update to keep your packages updated automatically

#+BEGIN_SRC emacs-lisp
(use-package auto-package-update
  :config
  (setq auto-package-update-delete-old-versions t)
  (setq auto-package-update-hide-results t)
  (auto-package-update-maybe))
#+END_SRC

Always compile packages, and use the newest version available.

#+BEGIN_SRC emacs-lisp
  (use-package auto-compile
    :config (auto-compile-on-load-mode)
    (setq load-prefer-newer t))
#+END_SRC

Disable TLS 1.3; ELPA has higher standards.
That’ll be the default in Emacs 26.3, I think, but I’m not there yet.

#+BEGIN_SRC emacs-lisp
  ;; (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
#+END_SRC

use-package supports git repository

#+begin_src emacs-lisp
  (use-package quelpa-use-package
    :disabled t
    :config
    (setq use-package-ensure-function 'quelpa))
#+end_src

* Use sensible-defaults.el

Use [[https://github.com/hrs/sensible-defaults.el][sensible-defaults.el]] for some basic settings.

#+BEGIN_SRC emacs-lisp
  (load-file "~/.emacs.d/sensible-defaults.el")
  (sensible-defaults/use-all-settings)
  (sensible-defaults/use-all-keybindings)
  (sensible-defaults/backup-to-temp-directory)
#+END_SRC

* Set personal information
** Who am I? Where am I?

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "MattLu"
        user-mail-address "lu.man@outlook.com"
        calendar-latitude 39.97
        calendar-longitude 116.34
        calendar-location-name "zhongkeyuanQingniangongyu H2209")
#+END_SRC

* Add =resources= to =load-path=

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/resources/")
#+END_SRC

* Utility functions

Define a big ol' bunch of handy utility functions.

#+BEGIN_SRC emacs-lisp
  (defun MattLu/view-buffer-name ()
    "Display the filename of the current buffer."
    (interactive)
    (message (buffer-file-name)))

  (defun MattLu/rename-file (new-name)
    (interactive "FNew name: ")
    (let ((filename (buffer-file-name)))
      (if filename
          (progn
            (when (buffer-modified-p)
               (save-buffer))
            (rename-file filename new-name t)
            (kill-buffer (current-buffer))
            (find-file new-name)
            (message "Renamed '%s' -> '%s'" filename new-name))
        (message "Buffer '%s' isn't backed by a file!" (buffer-name)))))

  (defun MattLu/generate-scratch-buffer ()
    "Create and switch to a temporary scratch buffer with a random
       name."
    (interactive)
    (switch-to-buffer (make-temp-name "scratch-")))

  (defun MattLu/unfill-paragraph ()
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive)
    (let ((fill-column (point-max)))
      (fill-paragraph nil)))

  (defun MattLu/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (defun MattLu/visit-last-dired-file ()
    "Open the last file in an open dired buffer."
    (end-of-buffer)
    (previous-line)
    (dired-find-file))

  (defun MattLu/visit-last-migration ()
    "Open the last file in 'db/migrate/'. Relies on projectile. Pretty sloppy."
    (interactive)
    (dired (expand-file-name "db/migrate" (projectile-project-root)))
    (MattLu/visit-last-dired-file)
    (kill-buffer "migrate"))

  (defun MattLu/add-auto-mode (mode &rest patterns)
    "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
    (dolist (pattern patterns)
      (add-to-list 'auto-mode-alist (cons pattern mode))))

  (defun MattLu/find-file-as-sudo ()
    (interactive)
    (let ((file-name (buffer-file-name)))
      (when file-name
        (find-alternate-file (concat "/sudo::" file-name)))))

  (defun MattLu/region-or-word ()
    (if mark-active
        (buffer-substring-no-properties (region-beginning)
                                        (region-end))
      (thing-at-point 'word)))

  (defun MattLu/insert-random-string (len)
    "Insert a random alphanumeric string of length len."
    (interactive)
    (let ((mycharset "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstyvwxyz"))
      (dotimes (i len)
        (insert (elt mycharset (random (length mycharset)))))))

  (defun MattLu/generate-password ()
    "Insert a good alphanumeric password of length 30."
    (interactive)
    (MattLu/insert-random-string 30))

  (defun MattLu/append-to-path (path)
    "Add a path both to the $PATH variable and to Emacs' exec-path."
    (setenv "PATH" (concat (getenv "PATH") ":" path))
    (add-to-list 'exec-path path))
#+END_SRC

* UI preferences
** Tweak window chrome

I don't usually use the menu or scroll bar, and they take up useful space.

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode -1)
#+END_SRC

** Use fancy lambdas

Why not?

#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode t)
#+END_SRC

** Load up a theme
*** personal color preferences

 better vertical border and region color


#+BEGIN_SRC emacs-lisp
  ;; Set symbol for the border │ or ┃
  (set-display-table-slot standard-display-table
                          'vertical-border
                          (make-glyph-code ?┃))
#+END_SRC

#+begin_src emacs-lisp
  (defun transparency (value)
    "Sets the transparency of the frame window. 0=transparent/100=opaque."
    (interactive "Transparency Value 0 - 100 opaque:")
    (set-frame-parameter (selected-frame) 'alpha value))
#+end_src

custom face when running in 256-color terminal
#+begin_src emacs-lisp
  (defun MattLu/load-custom-face-el ()
    (if (eq 256 (display-color-cells))
        (load-file "~/.emacs.d/custom-face.el")))

  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame)
                  (with-selected-frame
                      frame (MattLu/load-custom-face-el))))
    (MattLu/load-custom-face-el))
#+end_src

*** solarized-theme
I like the solarized-dark theme. I prefer keeping all the characters in the same
side and font, though.

#+BEGIN_SRC emacs-lisp
  (defun MattLu/apply-solarized-theme ()
    (setq solarized-scale-org-headlines nil)
    (transparency 98)
    (load-theme 'solarized-light t))
#+END_SRC

If this code is being evaluated by =emacs --daemon=, ensure that each subsequent
frame is themed appropriately.

#+BEGIN_SRC emacs-lisp
  (use-package solarized-theme
    :if (display-graphic-p)
    :config
    (if (daemonp)
        (add-hook 'after-make-frame-functions
                  (lambda (frame)
                      (MattLu/apply-solarized-theme)))
      (MattLu/apply-solarized-theme)))
#+END_SRC

*** nord theme
I'm currently using the "nord" theme. I've got a scenic wallpaper, so just a
hint of transparency looks lovely and isn't distracting or hard to read.

#+BEGIN_SRC emacs-lisp
  (defun MattLu/apply-nord-theme ()
    "Apply the `nord' theme and make frames just slightly transparent."
    (load-theme 'nord t))
#+END_SRC

If this code is being evaluated by =emacs --daemon=, ensure that each subsequent
frame is themed appropriately.

#+BEGIN_SRC emacs-lisp
  (use-package nord-theme
    :if (not (display-graphic-p))
    :config
    (if (daemonp)
        (add-hook 'after-make-frame-functions
                  (lambda (frame)
                    (with-selected-frame frame (MattLu/apply-nord-theme))))
      (MattLu/apply-nord-theme)))
#+END_SRC

** Configure =powerline=

#+begin_src emacs-lisp
  (setq MattLu/minor-mode-direct '(flymake-mode projectile-mode))
  (defun powerline-minor-modes-modify (orig-fun &rest args)
    "Change poweline-minor-modes display"
    (let* ((MattLu/default-mode-alist minor-mode-alist)
           (minor-mode-alist
            (list `(:propertize
                    ("" (:eval (--filter (memq (car it) MattLu/minor-mode-direct)
                                         MattLu/default-mode-alist)))
                    mouse-face mode-line-highlight
                    help-echo "Minor mode
    mouse-1: Display minor mode menu
    mouse-2: Show help for minor mode
    mouse-3: Toggle minor modes"
                    local-map ,mode-line-minor-mode-keymap)
                  " ")))
      (apply orig-fun args)))
#+end_src

#+BEGIN_SRC emacs-lisp
  (use-package powerline
    :config
    (powerline-center-theme)
    (advice-add 'powerline-minor-modes
                :around 'powerline-minor-modes-modify))
#+end_SRC

** Scroll conservatively

When point goes outside the window, Emacs usually recenters the buffer point.
I'm not crazy about that. This changes scrolling behavior to only scroll as far
as point goes.

#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC

** Set default font and configure font resizing

I'm partial to Inconsolata.

The standard =text-scale-= functions just resize the text in the current buffer;
I'd generally like to resize the text in /every/ buffer, and I usually want to
change the size of the modeline, too (this is especially helpful when
presenting). These functions and bindings let me resize everything all together!

Note that this overrides the default font-related keybindings from
=sensible-defaults=.

#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'gnu/linux)
     (setq MattLu/default-font "Ubuntu Mono")
    (setq MattLu/default-font "Source Code Variable"))
      (setq MattLu/default-font-size 12)
      (setq MattLu/current-font-size MattLu/default-font-size)

      (setq MattLu/font-change-increment 1.1)

      (defun MattLu/font-code ()
        "Return a string representing the current font (like \"Inconsolata-14\")."
        (concat MattLu/default-font "-" (number-to-string MattLu/current-font-size)))

      (defun MattLu/set-font-size ()
        "Set the font to `MattLu/default-font' at `MattLu/current-font-size'.
      Set that for the current frame, and also make it the default for
      other, future frames."
        (let ((font-code (MattLu/font-code)))
          (add-to-list 'default-frame-alist (cons 'font font-code))
          (set-frame-font font-code)))

      (defun MattLu/reset-font-size ()
        "Change font size back to `MattLu/default-font-size'."
        (interactive)
        (setq MattLu/current-font-size MattLu/default-font-size)
        (MattLu/set-font-size))

      (defun MattLu/increase-font-size ()
        "Increase current font size by a factor of `MattLu/font-change-increment'."
        (interactive)
        (setq MattLu/current-font-size
              (ceiling (* MattLu/current-font-size MattLu/font-change-increment)))
        (MattLu/set-font-size))

      (defun MattLu/decrease-font-size ()
        "Decrease current font size by a factor of `MattLu/font-change-increment', down to a minimum size of 1."
        (interactive)
        (setq MattLu/current-font-size
              (max 1
                   (floor (/ MattLu/current-font-size MattLu/font-change-increment))))
        (MattLu/set-font-size))

      (define-key global-map (kbd "C-)") 'MattLu/reset-font-size)
      (define-key global-map (kbd "C-+") 'MattLu/increase-font-size)
    ;;  (define-key global-map (kbd "C-=") 'MattLu/increase-font-size)
  ;;    (define-key global-map (kbd "C-c -") 'MattLu/decrease-font-size)
    ;; (define-key global-map (kbd "C--") nil)

      (MattLu/reset-font-size)
#+END_SRC

** Highlight the current line

=global-hl-line-mode= softly highlights the background color of the line
containing point. It makes it a bit easier to find point, and it's useful when
pairing or presenting code.

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode)
#+END_SRC

** Highlight uncommitted changes

Use the =diff-hl= package to highlight changed-and-uncommitted lines when
programming.

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
   :hook ((prog-mode vc-dir-mode) . turn-on-diff-hl-mode))
 #+END_SRC

** Display line number

#+BEGIN_SRC emacs-lisp
  (setq display-line-numbers-type 'visual)
  (global-display-line-numbers-mode)
#+END_SRC

** Using highlight indentation

#+BEGIN_SRC emacs-lisp
  (use-package highlight-indent-guides
    :hook (prog-mode . highlight-indent-guides-mode)
    :config
    (setq highlight-indent-guides-method 'character)
    (setq highlight-indent-guides-responsive 'top)
    (setq highlight-indent-guides-auto-enabled nil))
    ;; (setq highlight-indent-guides-delay 0.1)
#+END_SRC

** display system Information

#+BEGIN_SRC emacs-lisp
  (use-package symon
    :config
    (setq symon-delay 20)
    (symon-mode))
#+END_SRC

** Profile

 set profile report line wide
 most of the calling is too deep to show in 80 characters.
#+begin_src emacs-lisp
  (eval-after-load "profiler"
    '(progn
       (setf (caar profiler-report-cpu-line-format) 200
             (caar profiler-report-memory-line-format) 200)))
#+end_src

* Project management

I use a few packages in virtually every programming or writing environment to
manage the project, handle auto-completion, search for terms, and deal with
version control. That's all in here.

** =ripgrep=

Install and configure [[https://github.com/Wilfred/deadgrep][deadgrep]] as an interface to =ripgrep=.

#+begin_src emacs-lisp
  (use-package deadgrep)
#+end_src

** =company-mode=

Use =company-mode= everywhere.

#+begin_src emacs-lisp
  (use-package company
    :config
    (add-hook 'after-init-hook 'global-company-mode)
    (setq company-tooltip-limit 10)                      ; bigger popup window
    (setq company-idle-delay .1)                         ; decrease delay before autocompletion popup shows
    (setq company-echo-delay 0)                          ; remove annoying blinking
    (setq company-minimum-prefix-length 3)
    (setq company-transformers '(company-sort-by-occurrence)) ; weight by frequency
    (setq company-show-numbers t)
    (setq company-require-match nil)
    (setq company-selection-wrap-around t)
    (setq company-backends '(company-capf
                             company-files
                             company-dabbrev
                             company-dabbrev-code
                             company-keywords
                             company-ispell
                             company-oddmuse)))
#+end_src

#+begin_src emacs-lisp
  (use-package company-statistics
    :config
    (add-hook 'after-init-hook 'company-statistics-mode))
#+end_src

Set TAB for complete cycle

#+begin_src emacs-lisp
  (eval-after-load 'company
    '(progn
       (define-key company-active-map (kbd "TAB") 'company-complete-common-or-cycle)
       (define-key company-active-map (kbd "<tab>") 'company-complete-common-or-cycle)
       (define-key company-active-map (kbd "C-n") 'company-select-next)
       (define-key company-active-map (kbd "C-o") 'company-other-backend)
       (define-key company-active-map (kbd "C-p") 'company-select-previous)
       (define-key company-active-map (kbd "C-v") 'company-next-page)
       (define-key company-active-map (kbd "M-v") 'company-previous-page)))
#+end_src

** smart-jump

This packages tries to smartly go to definition leveraging several methods to do so.
If one method fails, this package will go on to the next one,
eventually falling back to =dumb-jump=.

#+begin_src emacs-lisp
  (use-package smart-jump
    :custom
    (smart-jump-default-mode-list
     '(eglot
       elisp-mode
       erlang-mode
       haskell-mode
       lisp-mode
       ruby-mode
       rust-mode
       scheme
       swift-mode))
    :config
    (smart-jump-setup-default-registers)
    (smart-jump-register :modes '(c-mode c++-mode python-mode)
                         :jump-fn 'ymcd-goto
                         :refs-fn 'ycmd-goto-references
                         :should-jump (lambda ()
                                        (bound-and-true-p ycmd-mode))
                         :heuristic 'point
                         :async 2000
                         :order 1)

    (smart-jump-register :modes '(c-mode c++-mode python-mode)
                         :jump-fn 'ggtags-find-tag-dwim
                         :pop-fn 'ggtags-prev-mark
                         :refs-fn 'ggtags-find-reference
                         :should-jump t
                         :heuristic 'point
                         :async 3000
                         :order 2))
#+end_src

** =dumb-jump=

The =dumb-jump= package works well enough in a [[https://github.com/jacktasia/dumb-jump#supported-languages][ton of environments]], and it
doesn't require any additional setup. bounding as official recommendation.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :bind
    (("M-g o" . dumb-jump-go-other-window)
     ("M-g j" . dumb-jump-go)
     ("M-g b" . dumb-jump-back)
     ("M-g i" . dumb-jump-go-prompt)
     ("M-g x" . dumb-jump-go-prefer-external)
     ("M-g z" . dumb-jump-go-prefer-external-other-window))

    :config
    (setq dumb-jump-force-searcher 'rg)
    (setq dumb-jump-selector 'ivy))
#+end_src

** flymake

#+BEGIN_SRC emacs-lisp
  (use-package flymake
    :bind (:map flymake-mode-map
                ("C-c [" . flymake-goto-prev-error)
                ("C-c ]" . flymake-goto-next-error))
    :config
    (defun flymake--transform-mode-line-format (ret)
      "Change the output of `flymake--mode-line-format'."
      (setf (seq-elt (car ret) 1) " Φ")
      ret)
    (advice-add #'flymake--mode-line-format
                :filter-return #'flymake--transform-mode-line-format))
#+END_SRC

** =flycheck=

 #+begin_src emacs-lisp
   (use-package let-alist)
   (use-package flycheck)
 #+end_src

** =magit=

I use =magit= to handle version control. It's lovely, but I tweak a few things:

- I bring up the status menu with =C-x g=.
- The default behavior of =magit= is to ask before pushing. I haven't had any
  problems with accidentally pushing, so I'd rather not confirm that every time.
- Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes
  beyond 50 characters.
- On the command line I'll generally push a new branch with a plain old =git
  push=, which automatically creates a tracking branch on (usually) =origin=.
  Magit, by default, wants me to manually specify an upstream branch. This binds
  =P P= to =magit-push-implicitly=, which is just a wrapper around =git push
  -v=. Convenient!
- I'd like to start in the insert state when writing a commit message.

#+begin_src emacs-lisp
  (use-package magit
    :bind
    ("C-x g" . magit-status)

    :config
    (use-package with-editor)
    (setq magit-push-always-verify nil)
    (setq git-commit-summary-max-length 50)
    (with-eval-after-load 'magit-remote
      (magit-define-popup-action 'magit-push-popup ?P
        'magit-push-implicitly--desc
        'magit-push-implicitly ?p t))

    ;; (setq magit-refresh-status-buffer nil)
    (setq auto-revert-buffer-list-filter
          'magit-auto-revert-repository-buffers-p)
    (setq magit-diff-refine-hunk nil)
    (setq magit-highlight-indentation nil)
    (setq magit-highlight-trailing-whitespace nil)
    (setq magit-highlight-whitespace nil)
    (setq magit-revision-insert-related-refs nil)
    (setq magit-use-overlays t)
    (add-hook 'git-commit-mode-hook 'turn-on-flyspell))
#+end_src

I've been playing around with the newly-released =forge= for managing GitHub PRs
and issues. Seems slick so far.

#+begin_src emacs-lisp
  ;; (use-package ghub)
  ;; (use-package forge)
#+end_src

I'm also partial to =git-timemachine=, which lets you quickly page through the
history of a file.

#+begin_src emacs-lisp
  (use-package git-timemachine)
#+end_src

Some projectile is managed by git-lfs, we need to extent magit

#+begin_src emacs-lisp
  (use-package magit-lfs
    :after (magit))
#+end_src

** =projectile=

Projectile's default binding of =projectile-ag= to =C-c p s s= is clunky enough
that I rarely use it (and forget it when I need it). This binds it to the
easier-to-type =C-c v= to useful searches.

Bind =C-p= to fuzzy-finding files in the current project. We also need to
explicitly set that in a few other modes.

I use =ivy= as my completion system.

When I visit a project with =projectile-switch-project=, the default action is
to search for a file in that project. I'd rather just open up the top-level
directory of the project in =dired= and find (or create) new files from there.

I'd like to /always/ be able to recursively fuzzy-search for files, not just
when I'm in a Projectile-defined project. I use the current directory as a
project root (if I'm not in a "real" project).

#+begin_src emacs-lisp
  (use-package projectile
    :bind
    ("C-c v" . deadgrep)
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :config
    (projectile-global-mode)
    (setq frame-title-format '((:eval (projectile-project-name))))
    (add-to-list 'projectile-project-root-files-bottom-up "compile_commands.json")
    (setq projectile-completion-system 'ivy)
    (setq projectile-sort-order 'recently-active)
    (setq projectile-switch-project-action 'projectile-dired)
    (setq projectile-require-project-root nil)
    (setq projectile-mode-line-prefix "P")
    (setq projectile-mode-line-function
          '(lambda () (format "[%s]" (projectile-project-name)))))
#+end_src

** =undo-tree=

I like tree-based undo management. I only rarely need it, but when I do, oh boy.

#+begin_src emacs-lisp
  (use-package undo-tree)
#+end_src

** =GDB=

using Realgud to debug source code

#+BEGIN_SRC emacs-lisp
  (use-package realgud)
#+END_SRC

** Shell config

Indent with 2 spaces.

#+BEGIN_SRC emacs-lisp
  (add-hook 'sh-mode-hook
            (lambda ()
              (setq sh-basic-offset 2
                    sh-indentation 2)))
#+END_SRC

Force open shell in the current buffer
#+BEGIN_SRC emacs-lisp
  (push (cons "\\*shell\\*" display-buffer--same-window-action) display-buffer-alist)
#+END_SRC

Add shell completion
#+BEGIN_SRC emacs-lisp
  (use-package bash-completion
    :config (bash-completion-setup))
#+END_SRC

use company instead of ivy which would invoke minibuffer
#+BEGIN_SRC emacs-lisp
  (define-key shell-mode-map (kbd "TAB") 'company-complete)
#+END_SRC

Get environment variable in Shell and set them to Emacs
#+begin_src emacs-lisp
  (defun MattLu/get-shell-env-value-and-set-emacs ()
  ; get environment variable form shell and set to emacs
    (interactive)
    (let ((env-var '("PATH" "LD_LIBRARY_PATH")))
      (mapcar #'shell-copy-environment-variable env-var)
      (setq python-shell-process-environment
            (mapcar (lambda (x) (format "%s=%s" x (getenv x)))
                    env-var))))

  (define-key shell-mode-map (kbd "C-c x") 'MattLu/get-shell-env-value-and-set-emacs)
#+end_src

** COMMENT Multiple desktop config

#+BEGIN_SRC emacs-lisp
  (bind-keys*
   ("M-s" . select-frame-by-name)
   ("C-c n" . set-frame-name))
#+END_SRC

** Workgroups another way to organize workspace

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'winner-mode)
    (winner-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package workgroups2
    :config
    (setq wg-session-load-on-start nil)
    (setq wg-session-file "~/.emacs.d/.emacs_workgroups")
    (setq wg-prefix-key (kbd "C-c z"))
    (setq wg-workgroups-mode-exit-save-behavior "none")
    (setq wg-dissociate-buffer-on-kill-buffer nil)
    (bind-keys* ("M-s" . wg-switch-to-workgroup))
    (workgroups-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; (setq desktop-restore-forces-onscreen nil)
  ;; (desktop-save-mode)
  ;; (add-hook 'server-after-make-frame-hook 'desktop-read)
  ;; (bind-keys*
  ;;  ("M-s" . select-frame-by-name)
  ;;  ("C-c n" . set-frame-name))
#+END_SRC

** CMake

CMake is a meta-build system that is commonly used in C++ projects.

#+BEGIN_SRC emacs-lisp
  (use-package cmake-mode
    :mode ("CMakeLists.txt" "\\.cmake\\'"))
#+END_SRC

Enable type-aware highlighting support for CMake files:

#+BEGIN_SRC emacs-lisp
  (use-package cmake-font-lock
    :hook (cmake-mode . cmake-font-lock-activate))
#+END_SRC

** Bazel

Bazel is a build system created by Google:

#+BEGIN_SRC emacs-lisp
  (use-package bazel-mode
    :defer t)
#+END_SRC

** imenu-list

show function and variable tree in side buffer
#+BEGIN_SRC emacs-lisp
  (use-package imenu-list
    :bind ("C-c i" . imenu-list-smart-toggle)
    :config
    (setq imenu-list-focus-after-activation t))
#+END_SRC

* Programming customization
** common settings
*** Editing
I like shallow indentation, but tabs are displayed as 8 characters by default.
This reduces that.

#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 4)
#+END_SRC

Treating terms in CamelCase symbols as separate words makes editing a little
easier for me, so I like to use =subword-mode= everywhere.

#+BEGIN_SRC emacs-lisp
  (use-package subword
    :config (global-subword-mode 1))
#+END_SRC

Compilation output goes to the =*compilation*= buffer. I rarely have that window
selected, so the compilation output disappears past the bottom of the window.
This automatically scrolls the compilation window so I can always see the
output.

#+BEGIN_SRC emacs-lisp
  (setq compilation-scroll-output t)
#+END_SRC

flyspell can really help programmers as well by pointing out typos they make
in comments.
#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :config
    (setq ispell-program-name "aspell"; use aspell instead of ispell
          ispell-extra-args '("--sug-mode=ultra"))
    :hook
    ((prog-mode . flyspell-prog-mode)
     (text-mode . flyspell-mode)
     (org-mode . flyspell-mode)))
#+END_SRC

Use =smartparens=
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :config
    (smartparens-global-mode 1))
#+END_SRC

*** YCMD

YouCompltedMe setup

#+BEGIN_SRC emacs-lisp
  (use-package ycmd
    :hook ((c-mode c++-mode python-mode typescript-mode)
           . ycmd-mode)
    :config
    (setq request-message-level -1)
    (set-variable 'ycmd-server-command
                  `("python3" "-u" ,
                    (file-truename "~/.emacs.d/ycmd/ycmd"))))

  (defun MattLu/company-mode-c-mode-hook ()
    (set (make-local-variable 'company-backends)
         (remove 'company-capf company-backends))
    (add-to-list 'company-backends 'company-ycmd)
    (add-to-list 'company-backends 'company-capf))

  (defun MattLu/company-mode-py/ts/js-mode-hook ()
    (add-to-list (make-local-variable 'company-backends)
                 'company-ycmd))

  (use-package company-ycmd
    :config
    (setq company-ycmd-insert-arguments nil)
    :hook
    (((python-mode typescript-mode) . MattLu/company-mode-py/ts/js-mode-hook)
     ((c-mode c++-mode) . MattLu/company-mode-c-mode-hook)))
#+END_SRC

*** eglot LSP

LSP client
#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :commands
    (eglot eglot-ensure)
    :bind (:map eglot-mode-map
                ("C-c u" . eglot-format)
                ("C-c h" . eglot-help-at-point))
    :config
    (setq eglot-stay-out-of '(company))
    (add-to-list 'eglot-server-programs '((c++-mode c-mode) "clangd"))
    (setq eglot-events-buffer-size 200)
    (setq eglot-autoreconnect 1)
    (setq eglot-autoshutdown t)
    (setq eglot-connect-timeout 10)
    (setq eglot-sync-connect nil)
    (add-to-list 'eglot-ignored-server-capabilites
                 :documentHighlightProvider)
    :hook
    ((c-mode c++-mode python-mode sh-mode typescript-mode)
     . eglot-ensure))
#+END_SRC

*** Tags

#+BEGIN_SRC emacs-lisp
  (use-package ggtags
    :config
    (define-key ggtags-mode-map (kbd "M-.") nil)
    (define-key ggtags-mode-map (kbd "M-]") nil))
#+END_SRC

*** Xref jump

Use Ivy as the interface to select from xref candidates.

#+BEGIN_SRC emacs-lisp
  (use-package ivy-xref
    :init
    ;; xref initialization is different in Emacs 27 - there are two different
    ;; variables which can be set rather than just one
    (when (>= emacs-major-version 27)
      (setq xref-show-definitions-function #'ivy-xref-show-defs))
    ;; Necessary in Emacs <27. In Emacs 27 it will affect all xref-based
    ;; commands other than xref-find-definitions (e.g. project-find-regexp)
    ;; as well
    (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))
#+END_SRC

*** Terminal

 I use =multi-term= to manage my shell sessions. It's bound to =C-c t=.

 #+BEGIN_SRC emacs-lisp
   (use-package multi-term
     :bind ("C-c t" . multi-term))
 #+END_SRC

 Use a login shell:

 #+BEGIN_SRC emacs-lisp
    (setq multi-term-program-switches "--login")
 #+END_SRC

 I add a bunch of hooks to =term-mode=:

 - I'd like links (URLs, etc) to be clickable.
 - Yanking in =term-mode= doesn't quite work. The text from the paste appears in
   the buffer but isn't sent to the shell process. This correctly binds =C-y= and
   middle-click to yank the way we'd expect.
 - I bind =M-o= to quickly change windows. I'd like that in terminals, too.
 - I don't want to perform =yasnippet= expansion when tab-completing.

 #+BEGIN_SRC emacs-lisp
   (defun MattLu/term-paste (&optional string)
     (interactive)
     (process-send-string
          (get-buffer-process (current-buffer))
          (if string string (current-kill 0))))

   (add-hook 'term-mode-hook
             (lambda ()
               (goto-address-mode)
               (define-key term-raw-map (kbd "C-y") 'MattLu/term-paste)
               (define-key term-raw-map (kbd "<mouse-2>") 'MattLu/term-paste)
               (define-key term-raw-map (kbd "M-o") 'other-window)
               (setq yas-dont-activate t)))
 #+END_SRC

*** Fold and unfold code blocks

 Emacs has a minor mode called hs-minor-mode that allows users to fold and hide blocks of text
 #+BEGIN_SRC emacs-lisp
   (defun MattLu/display-code-line-counts (ov)
     (when (eq 'code (overlay-get ov 'hs))
       (overlay-put ov 'display
                    (propertize
                     (format " … <%d>"
                             (count-lines (overlay-start ov)
                                          (overlay-end ov)))
                     'face '(:background "#ff0066" :foreground "color-16")))))

   (use-package hideshow
     :hook (prog-mode . hs-minor-mode)
     :bind (:map hs-minor-mode-map
                 ("C-c m" . hs-toggle-hiding))
     :config
     (setq hs-set-up-overlay 'MattLu/display-code-line-counts))
 #+END_SRC

*** Highlight variables

 #+BEGIN_SRC emacs-lisp
   (use-package symbol-overlay
     :bind (("M-i" . symbol-overlay-put)
            ("M-n" . symbol-overlay-jump-next)
            ("M-p" . symbol-overlay-jump-prev)
            ("M-N" . symbol-overlay-switch-forward)
            ("M-P" . symbol-overlay-switch-backward)
            ("M-C" . symbol-overlay-remove-all))
     :hook (prog-mode . symbol-overlay-mode))
 #+END_SRC

*** COMMENT Google Test

For running Google Tests from a given buffer

#+BEGIN_SRC emacs-lisp
  (use-package gtest-mode
    :load-path "~/.emacs.d/gtest-mode"
    :after cc-mode)
#+END_SRC

*** COMMENT Tree-sitter

using tree-sitter to manage Parser
#+begin_src emacs-lisp
  (use-package tree-sitter)
  (use-package tree-sitter-langs)
  (global-tree-sitter-mode)
#+end_src

** COMMENT C++

use modern cpp font lock to get better semantic highlight
#+BEGIN_SRC emacs-lisp
  (use-package modern-cpp-font-lock
    :hook (c++-mode . modern-c++-font-lock-mode))
#+END_SRC

** COMMENT Coq

Use =company-coq-mode=, which really helps make Proof General a more useful IDE.

I also like to disable =abbrev-mode=; it has a ton of abbreviations for Coq, but
they've always been unpleasant surprises for me.

#+BEGIN_SRC emacs-lisp
  (use-package company-coq
    :init
    (add-hook 'coq-mode-hook
              (lambda ()
                (company-coq-mode)
                (abbrev-mode 0)))
    :requires proof-general)
#+END_SRC

The default Proof General layout stacks the code, goal, and response buffers on
top of each other. I like to keep my code on one side and my goal and response
buffers on the other.

#+BEGIN_SRC emacs-lisp
  (setq proof-three-window-mode-policy 'hybrid)
#+END_SRC

The Proof General splash screen's pretty cute, but I don't need to see it every
time.

#+BEGIN_SRC emacs-lisp
  (setq proof-splash-enable nil)
#+END_SRC

** COMMENT Haskell

Enable =haskell-doc-mode=, which displays the type signature of a function, and
use smart indentation.

#+BEGIN_SRC emacs-lisp
;;  (MattLu/append-to-path "~/.cabal/bin")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :init
    (add-hook 'haskell-mode-hook
              (lambda ()
                (haskell-doc-mode)
                (interactive-haskell-mode)
                (turn-on-haskell-indent))))
#+END_SRC

** JavaScript and CoffeeScript

Indent everything by 2 spaces.

#+BEGIN_SRC emacs-lisp
  (setq js-indent-level 2)

  (add-hook 'coffee-mode-hook
            (lambda ()
              (yas-minor-mode 1)
              (setq coffee-tab-width 2)))
#+END_SRC

Clear js-mode-hook when parser json file

#+begin_src emacs-lisp
  (defun MattLu/js-mode-hook ()
    (unless (and (stringp buffer-file-name)
               (string-match "\\.json\\'" buffer-file-name))
      (eglot-ensure)
      (ycmd-mode)
      (MattLu/company-mode-py/ts/js-mode-hook)))
  (add-hook 'js-mode-hook 'MattLu/js-mode-hook)
#+end_src

** Lisps

I like to use =paredit= in Lisp modes to balance parentheses (and more!).

#+begin_src emacs-lisp
  (use-package paredit)
#+end_src

=rainbow-delimiters= is convenient for coloring matching parentheses.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters)
#+end_src

All the lisps have some shared features, so we want to do the same things for
 all of them. That includes using paredit, rainbow-delimiters, and highlighting
 the whole expression when point is on a parenthesis.

#+BEGIN_SRC emacs-lisp
  (setq lispy-mode-hooks
        '(clojure-mode-hook
          emacs-lisp-mode-hook
          lisp-mode-hook
          scheme-mode-hook))

  (dolist (hook lispy-mode-hooks)
    (add-hook hook (lambda ()
                     (paredit-mode)
                     (rainbow-delimiters-mode))))
#+END_SRC

If I'm writing in Emacs lisp I'd like to use =eldoc-mode= to display
documentation.

#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :config
    (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
    (setq eldoc-idle-delay 2))
#+END_SRC

I also like using flycheck-package to ensure that my Elisp packages are correctly formatted.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-package)

  (eval-after-load 'flycheck
    '(flycheck-package-setup))
#+END_SRC

** scheme

#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :config
    (setq geiser-active-implementations '(mit chicken guile racket chez)))
#+END_SRC

** Python

#+BEGIN_SRC emacs-lisp
  (use-package virtualenvwrapper
    :config
    (venv-initialize-interactive-shells) ;; if you want interactive shell support
    (venv-initialize-eshell) ;; if you want eshell support
    (setq venv-location '("~/venvPy/py3/"
                          "~/python/bmnett-3.5/"))
    (cond ((eq system-type 'gnu/linux)
           (venv-workon "bmnett-3.5"))
          ((eq system-type 'darwin)
           (venv-workon "py3"))))
#+END_SRC

Set ipython as interpreter

#+BEGIN_SRC emacs-lisp
  (setq python-shell-interpreter "ipython")
  (setq python-shell-interpreter-args "--simple-prompt -i")
  (setq py-ipython-command-args "--simple-prompt -i")
  (add-hook 'inferior-python-mode-hook
          (lambda ()
            (set (make-local-variable 'company-backends)
                 (remove 'company-capf company-backends))))
#+END_SRC

Indent 2 spaces.

#+BEGIN_SRC emacs-lisp
  (setq python-indent 4)
#+END_SRC

set realgud python debug command
#+BEGIN_SRC emacs-lisp
  (setq realgud:pdb-command-name "python -m pdb")
#+END_SRC


using Jupyter

#+BEGIN_SRC emacs-lisp
  (use-package ein
    :config
    (require 'ein-notebook)
    (setq ein:cell-max-num-outputs 10)
    (setq ein:completion-backend 'ein:use-company-backend)
    (add-hook 'ein:notebook-mode-hook
              (lambda ()
                (add-to-list (make-local-variable 'company-backends)
                             'ein:company-backend)))
    :commands (ein:notebooklist-open))
#+END_SRC

** =web-mode=

If I'm in =web-mode=, I'd like to:

- Color color-related words with =rainbow-mode=.
- Still be able to run RSpec tests from =web-mode= buffers.
- Indent everything with 2 spaces.

#+BEGIN_SRC emacs-lisp
 (use-package web-mode
    :init
    (use-package rainbow-mode)
    (use-package rspec-mode)
    :config
    (add-hook 'web-mode-hook 'rainbow-mode)
    (add-hook 'web-mode-hook 'rspec-mode)
    (setq web-mode-markup-indent-offset 2)
    :mode "\\.erb$"
           "\\.html$"
           "\\.php$"
           "\\.rhtml$")
#+END_SRC

Use =web-mode= with embedded Ruby files, regular HTML, and PHP.

** protocol buffer

   add Google protocol buffer support
#+BEGIN_SRC emacs-lisp
  (use-package protobuf-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.prototxt\\'" . protobuf-mode)))
#+END_SRC

** ReStructuredText

#+BEGIN_SRC emacs-lisp
  (use-package rst)
#+END_SRC

** typescript-mode

#+begin_src emacs-lisp
  (use-package typescript-mode)
#+end_src

* Org

Including org-tempo restores the <s-style easy-templates that were deprecated in Org 9.2.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure org-plus-contrib
    :config
    (put 'narrow-to-region 'disabled nil)
    (setq org-modules (cl-remove-duplicates
                       (append org-modules
                               '(org-tempo
                                 ox-md
                                 ox-beamer
                                 org-capture
                                 ox-latex
                                 ox-odt
                                 org-gnus)))))
#+END_SRC

I’d like the initial scratch buffer to be in Org:

#+BEGIN_SRC emacs-lisp
  (setq initial-major-mode 'org-mode)
#+END_SRC

** Display preferences

I like to see an outline of pretty bullets instead of a list of asterisks.

#+BEGIN_SRC emacs-lisp
  (defun MattLu/change-cdr-value (in-list key value)
    (when (consp in-list)
      (if (eq (car in-list) key)
          (setcdr in-list value)
        (progn
          (MattLu/change-cdr-value (car in-list) key value)
          (MattLu/change-cdr-value (cdr in-list) key value))
        )))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :config
    (add-hook 'org-mode-hook 'org-bullets-mode))
#+END_SRC

I like seeing a little downward-pointing arrow instead of the usual ellipsis
(=...=) that org displays when there's stuff under a header.

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis " …")
#+END_SRC

Use syntax highlighting in source blocks while editing.

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

Make TAB act as if it were issued in a buffer of the language's major mode.

#+BEGIN_SRC emacs-lisp
  (setq org-src-tab-acts-natively t)
#+END_SRC

When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC

Using build-in hide leading starts

#+BEGIN_SRC emacs-lisp
  (setq org-hide-leading-stars t)
  (setq org-pretty-entities t)
  (setq org-allow-promoting-top-level-subtree t)
  (setq org-email-link-description-format "%c: %.50s")
#+END_SRC

** Key-bindings

Bind a few handy keys.

#+BEGIN_SRC emacs-lisp
  (define-key global-map "\C-cl" 'org-store-link)
  (define-key global-map "\C-ca" 'org-agenda)
  (define-key global-map "\C-cc" 'org-capture)
  (define-key global-map "\C-cL" 'org-occur-link-in-agenda-files)
#+END_SRC

Hit =C-c g= to quickly open up my todo list.

#+BEGIN_SRC emacs-lisp
  (defun open-gtd-file ()
    "Open the master org TODO list."
    (interactive)
   ;; (MattLu/copy-tasks-from-inbox)
    (find-file org-gtd-file)
    (flycheck-mode -1)
    (end-of-buffer))

  (global-set-key (kbd "C-c g") 'open-gtd-file)
#+END_SRC


Hit =M-n= to quickly open up a capture template for a new todo.

#+BEGIN_SRC emacs-lisp
  (defun org-capture-todo ()
    (interactive)
    (org-capture :keys "t"))
#+END_SRC

#+begin_src emacs-lisp
  (setq org-special-ctrl-a/e 'reversed)
  (setq org-special-ctrl-k t)
  (setq org-support-shift-select t)
#+end_src

** Timing

Set headlines to STRT and clock-in when running a countdown

#+BEGIN_SRC emacs-lisp
  (org-clock-persistence-insinuate)
  (setq org-clock-display-default-range 'thisweek)
  (setq org-clock-persist t)
  (setq org-clock-idle-time 60)
  (setq org-clock-history-length 35)
  (setq org-clock-in-resume t)
  (setq org-clock-out-remove-zero-time-clocks t)
  (org-agenda-to-appt)
  (add-hook 'org-timer-set-hook
              (lambda ()
                (if (eq major-mode 'org-agenda-mode)
                    (call-interactively 'org-agenda-clock-in)
                  (call-interactively 'org-clock-in))))
    (add-hook 'org-timer-done-hook
              (lambda ()
                (if (and (eq major-mode 'org-agenda-mode)
                         org-clock-current-task)
                    (call-interactively 'org-agenda-clock-out)
                  (call-interactively 'org-clock-out))))
    (add-hook 'org-timer-pause-hook
              (lambda ()
                (if org-clock-current-task
                    (if (eq major-mode 'org-agenda-mode)
                        (call-interactively 'org-agenda-clock-out)
                      (call-interactively 'org-clock-out)))))
    (add-hook 'org-timer-stop-hook
              (lambda ()
                (if org-clock-current-task
                    (if (eq major-mode 'org-agenda-mode)
                        (call-interactively 'org-agenda-clock-out)
                      (call-interactively 'org-clock-out)))))
#+END_SRC

*** COMMENT icalendar

#+BEGIN_SRC emacs-lisp
  (setq org-combined-agenda-icalendar-file "~/.Org/matt.ics")
  (setq org-icalendar-combined-name "MattLu ORG")
  (setq org-icalendar-use-scheduled '(todo-start event-if-todo event-if-not-todo))
  (setq org-icalendar-use-deadline '(todo-due event-if-todo event-if-not-todo))
  (setq org-icalendar-timezone "China/Beijing")
  (setq org-icalendar-store-UID t)
#+END_SRC

** GTD

Store my org files in =~/org=, maintain an inbox in Dropbox, define the location
of an index file (my main todo list), and archive finished tasks in
=~/org/archive.org=.

#+BEGIN_SRC emacs-lisp
  (use-package org-pomodoro)
#+END_SRC

*** Keywords
#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/.Org")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (let ((fun (lambda (x)
                 (concat (file-name-as-directory org-directory) x))))
      (if (listp filename)
          (mapcar fun filename)
        (eval (list fun filename)))))

  (setq org-gtd-file (org-file-path "gtd.org"))
  (setq org-default-notes-file (org-file-path "note.org"))
  (setq org-scheduled-past-days 100)
  (setq org-stuck-projects '("+LEVEL=1" ("NEXT" "TODO" "DONE")))
  (setq org-tag-persistent-alist '(("Write" . ?w) ("Read" . ?r)))
  (setq org-tag-alist
        '((:startgroup)
          ("Handson" . ?o)
          (:grouptags)
          ("Write" . ?w) ("Code" . ?c) ("Tel" . ?t)
          (:endgroup)
          (:startgroup)
          ("Handsoff" . ?f)
          (:grouptags)
          ("Read" . ?r) ("View" . ?v) ("Listen" . ?l)
          (:endgroup)
          ("Mail" . ?@) ("Search" . ?s) ("Buy" . ?b)))
  (setq org-tags-column -74)
  (setq org-todo-keywords '((type "TODO" "STRT" "NEXT" "WAIT" "|" "DONE" "DELEGATED" "CANCELED")))
  (setq org-todo-repeat-to-state t)
  (setq org-use-property-inheritance t)
  (setq org-use-sub-superscripts nil)
  (setq org-todo-keyword-faces
        '(("STRT" . (:foreground "white" :inverse-video t))
          ("NEXT" . (:foreground "color-45" :weight bold))
          ("WAIT" . (:foreground "#889699" :inverse-video t))
          ("CANCELED" . (:foreground "#889699"))))
  (setq org-enforce-todo-dependencies t)
  (setq org-deadline-warning-days 7)
#+END_SRC

*** Capturing

Define a few common tasks as capture templates. Specifically

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("C" "Misc [inbox]" entry (file "~/.Org/inbox.org")
           "* TODO %a\n  :PROPERTIES:\n  :CAPTURED: %U\n  :END:\n"
           :prepend t :immediate-finish t)

          ("c" "Misc [inbox] (edit)" entry (file "~/.Org/inbox.org")
           "* TODO %?\n  :PROPERTIES:\n  :CAPTURED: %U\n  :END:\n\n- %a" :prepend t)

          ("r" "RDV Perso" entry (file+headline "~/.Org/rdv.org" "RDV Perso")
           "* RDV avec %:fromname %?\n  :PROPERTIES:\n  :CAPTURED: %U\n  :END:\n\n- %a" :prepend t)

          ("R" "RDV Etalab" entry (file+headline "~/.Org/rdv-etalab.org" "RDV Etalab")
           "* RDV avec %:fromname %?\n  :PROPERTIES:\n  :CAPTURED: %U\n  :END:\n\n- %a" :prepend t)

          ("t" "Tickler" entry (file+headline "~/.Org/tickler.org" "Tickler")
           "* %i%? \n  :PROPERTIES:\n  :CAPTURED: %U\n  :END:\n\n- %a\n\n%i" :prepend t)))

  (setq org-capture-templates-contexts
        '(("r" ((in-mode . "gnus-summary-mode")
                (in-mode . "gnus-article-mode")
                (in-mode . "message-mode")))
          ("R" ((in-mode . "gnus-summary-mode")
                (in-mode . "gnus-article-mode")
                (in-mode . "message-mode")))))
#+END_SRC

*** Refine & Archive

set org-refile level deep to max 3

#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets '((("~/.Org/gtd.org") . (:maxlevel . 3))
                             (("~/.Org/someday.org") . (:maxlevel . 1))
                             (("~/.Org/tickler.org") . (:maxlevel . 2))))

  (setq org-refile-use-outline-path 'file)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-cache nil)
  (setq org-reverse-note-order t)
  (setq org-outline-path-complete-in-steps nil)
  ;; (setq org-archive-default-command 'org-archive-to-archive-sibling)
#+END_SRC

Hitting =C-c C-x C-s= will mark a todo as done and move it to an appropriate
place in the archive.

#+BEGIN_SRC emacs-lisp
  (setq org-archive-location
        (concat (org-file-path "archive.org") "::datetree/"))

  (defun MattLu/mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it."
    (interactive)
    (let ((ts (org-get-todo-state)))
      (when (not (or (equal ts "DONE")
                     (equal ts "DELEGATED")
                     (equal ts "CANCELLED")))
        (org-todo 'done)))
    (org-archive-subtree))

  (define-key org-mode-map (kbd "C-c C-x C-s") 'MattLu/mark-done-and-archive)
#+END_SRC

Record the time that a todo was archived.

#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC

auto save org file
#+BEGIN_SRC emacs-lisp
  (advice-add 'org-archive-subtree :after 'org-save-all-org-buffers)
  (advice-add 'org-agenda-quit :before 'org-save-all-org-buffers)
#+END_SRC

*** Agenda

#+begin_src emacs-lisp
  (use-package org-super-agenda)
#+end_src


#+BEGIN_SRC emacs-lisp
  ;; Set headlines to STRT when clocking in
  (add-hook 'org-clock-in-hook (lambda() (org-todo "STRT")))
  ;; (setq org-agenda-diary-file "/home/guerry/org/rdv.org")
  (setq org-agenda-dim-blocked-tasks nil)
  (setq org-log-into-drawer "LOGBOOK")
  (setq org-agenda-entry-text-maxlines 10)
  (setq org-timer-default-timer 25)
  (setq org-agenda-diary-file (org-file-path '("rdv.org" "gtd.org" "inbox.org")))
  (setq org-agenda-files (org-file-path '("inbox.org" "gtd.org" "tickler.org" "someday.org")))
  (setq org-agenda-prefix-format
        '((agenda . " %i %-12:c%?-14t%s")
          (timeline . "  % s")
          (todo . " %i %-14:c")
          (tags . " %i %-14:c")
          (search . " %i %-14:c")))
  (setq org-agenda-restore-windows-after-quit t)
  (setq org-agenda-show-inherited-tags nil)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-timestamp-if-done t)
  (setq org-agenda-sorting-strategy
        '((agenda time-up) (todo time-up) (tags time-up) (search time-up)))
  (setq org-agenda-tags-todo-honor-ignore-options t)
  (setq org-agenda-use-tag-inheritance nil)
  (setq org-agenda-window-frame-fractions '(0.0 . 0.5))
  (setq org-agenda-deadline-faces
        '((1.0001 . org-warning)              ; due yesterday or before
          (0.0    . org-upcoming-deadline)))  ; due today or later
#+END_SRC

*** Review

list stuck projects
#+BEGIN_SRC emacs-lisp
  (setq org-stuck-projects
        '("TODO={.+}/-DONE" nil nil "SCHEDULED:\\|DEADLINE:"))
#+END_SRC

using priority to organize my life
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-custom-commands
        `(
          ;; Week agenda for rendez-vous and tasks
          ("%" "Rendez-vous" agenda* "Week planning"
           ((org-agenda-span 'week)
            (org-agenda-files (org-file-path '("rdv.org")))
            ;; (org-deadline-warning-days 3)
            (org-agenda-sorting-strategy
             '(todo-state-up time-up priority-down))))

          ("!" tags-todo "+DEADLINE<=\"<+7d>\"")
          ("=" tags-todo "+SCHEDULED<=\"<now>\"")
          ("?" "WAIT (gtd)" tags-todo "TODO={WAIT}"
           ((org-agenda-files (org-file-path '("gtd.org")))
            (org-agenda-sorting-strategy
             '(todo-state-up priority-down time-up))))
          ("@" tags-todo "+Mail+TODO={NEXT\\|STRT\\|WAIT}")

          ("w" "Report DONE/CANCELED/DELEGATED"
           agenda ""
           ((org-agenda-span 'week)
            (org-agenda-start-on-weekday 0)
            (org-agenda-start-with-log-mode '(closed state clock))
            (org-agenda-files (org-file-path '("gtd.org" "archive.org")))
            (org-agenda-skip-function
                 '(org-agenda-skip-entry-if 'nottodo 'done))
            (org-agenda-sorting-strategy '(timestamp-up))))

          ("" . "Task and rendez-vous for today")
          ("" "Travail (tout)" agenda "Tasks and rdv for today"
           ((org-agenda-span 1)
            (org-agenda-files (org-file-path '("gtd.org" "matt.org")))
            (org-deadline-warning-days 3)
            (org-agenda-sorting-strategy
             '(todo-state-up time-up priority-down))))
          (" " "Libre (tout)" agenda "Tasks and rdv for today"
           ((org-agenda-span 1)
            (org-agenda-files (org-file-path '("libre.org")))
            (org-deadline-warning-days 3)
            (org-agenda-sorting-strategy
             '(todo-state-up priority-down time-up))))
          ("e" "Etalab TODO" tags-todo "TODO={STRT\\|NEXT\\|TODO}"
           ((org-agenda-files (org-file-path '("libre.org")))
            (org-agenda-category-filter-preset '("+ETL"))
            (org-agenda-sorting-strategy
             '(todo-state-up time-up priority-down))))

          ("n" "NEXT action" tags-todo "TODO={NEXT\\|STRT}"
           ((org-agenda-files (org-file-path '("gtd.org")))
            (org-agenda-sorting-strategy
             '(todo-state-down time-up priority-down))))

          ("x" . "Scheduled for today")
          ("xx" "Agenda work" agenda "Work scheduled for today"
           ((org-agenda-span 1)
            (org-deadline-warning-days 3)
            (org-agenda-entry-types '(:timestamp :scheduled))
            (org-agenda-sorting-strategy
             '(todo-state-up priority-down time-up))))
          ("xX" "Agenda libre" agenda "Libre scheduled for today"
           ((org-agenda-span 1)
            (org-deadline-warning-days 3)
            (org-agenda-files (org-file-path '("libre.org")))
            (org-agenda-entry-types '(:timestamp :scheduled))
            (org-agenda-sorting-strategy
             '(todo-state-up priority-down time-up))))

          ("z" . "Deadlines for today")
          ("zz" "Work deadlines" agenda "Past/upcoming work deadlines"
           ((org-agenda-span 1)
            (org-deadline-warning-days 15)
            (org-agenda-entry-types '(:deadline))
            (org-agenda-sorting-strategy
             '(todo-state-up priority-down time-up))))
          ("zZ" "Libre deadlines" agenda "Past/upcoming leisure deadlines"
           ((org-agenda-span 1)
            (org-deadline-warning-days 15)
            (org-agenda-files (org-file-path '("libre.org")))
            (org-agenda-entry-types '(:deadline))
            (org-agenda-sorting-strategy
             '(todo-state-up priority-down time-up))))

          ("r" . "Read")
          ("rr" tags-todo "+Read+TODO={NEXT\\|STRT}")
          ("rR" tags-todo "+Read+TODO={NEXT\\|STRT}"
           ((org-agenda-files '("~/org/libre.org"))))
          ("v" . "View")
          ("vv" tags-todo "+View+TODO={NEXT\\|STRT}")
          ("vV" tags-todo "+View+TODO={NEXT\\|STRT}"
           ((org-agenda-files (org-file-path '("libre.org")))))
          ("l" . "Listen")
          ("ll" tags-todo "+Listen+TODO={NEXT\\|STRT}")
          ("lL" tags-todo "+Listen+TODO={NEXT\\|STRT}"
           ((org-agenda-files (org-file-path '("libre.org")))))
          ("w" . "Write")
          ("ww" tags-todo "+Write+TODO={NEXT\\|STRT}")
          ("wW" tags-todo "+Write+TODO={NEXT\\|STRT}"
           ((org-agenda-files (org-file-path '("libre.org")))))
          ("c" . "Code")
          ("cc" tags-todo "+Code+TODO={NEXT\\|STRT}")
          ("cC" tags-todo "+Code+TODO={NEXT\\|STRT}"
           ((org-agenda-files (org-file-path '("libre.org")))))
          ))
#+END_SRC

** Edit

ob-async enables asynchronous execution of org-babel src blocks, using :async

#+BEGIN_SRC emacs-lisp
  (use-package ob-async
    :config
    (require 'org))
#+END_SRC

Programming languages support

#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (shell . t)
     (org . t)
     (scheme . t)
     (python . t)
     (dot . t)
     (gnuplot . t)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq org-babel-default-header-args
    '((:session . "none")
      (:results . "replace")
      (:exports . "code")
      (:cache . "no")
      (:noweb . "yes")
      (:hlines . "no")
      (:tangle . "no")
      (:padnewline . "yes")))
#+END_SRC

Don't ask before evaluating code blocks.

#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

Associate the "dot" language with the =graphviz-dot= major mode.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
#+END_SRC

Quickly insert a block of elisp:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" . "src emacs-lisp"))
#+END_SRC

Hook to update all blocks before saving

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
        (lambda() (add-hook 'before-save-hook
                'org-update-all-dblocks t t)))
  (setq org-insert-heading-respect-content t)
  (setq org-id-method 'uuidgen)
  (setq org-id-uuid-program "uuidgen")
  (setq org-use-speed-commands
    (lambda nil
      (and (looking-at org-outline-regexp-bol)
           (not (org-in-src-block-p t)))))
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
  (setq org-link-display-descriptive nil)
  (setq org-loop-over-headlines-in-active-region t)
  ;; (setq org-create-formula-image-program 'dvipng) ;; imagemagick
  (setq org-blank-before-new-entry '((heading . t) (plain-list-item . auto)))
  (setq org-fontify-whole-heading-line t)
  (setq org-global-properties '(("Effort_ALL" . "0:10 0:30 1:00 2:00 3:30 7:00")))
  (setq org-confirm-elisp-link-function nil)
  (setq org-confirm-shell-link-function nil)
#+END_SRC

*** LaTex
Automatically parse the file after loading it.

#+BEGIN_SRC emacs-lisp
  (setq TeX-parse-self t)
#+END_SRC

Always use =pdflatex= when compiling LaTeX documents. I don't really have any
use for DVIs.

#+BEGIN_SRC emacs-lisp
  (setq TeX-PDF-mode t)
#+END_SRC

Open compiled PDFs in =evince= instead of in the editor.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
        '(lambda ()
           (delete '("\\.pdf\\'" . default) org-file-apps)
           (add-to-list 'org-file-apps '("\\.pdf\\'" . "evince %s"))))
#+END_SRC

Enable a minor mode for dealing with math (it adds a few useful keybindings),
and always treat the current file as the "main" file. That's intentional, since
I'm usually actually in an org document.

#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (LaTeX-math-mode)
              (setq TeX-master t)))
#+END_SRC

** Exporting

Translate regular ol' straight quotes to typographically-correct curly quotes
when exporting.

#+BEGIN_SRC emacs-lisp
  (setq org-export-with-smart-quotes t)
  (setq org-export-default-language "en")
  (setq org-export-backends '(latex odt icalendar html ascii))
  (setq org-export-with-archived-trees nil)
  (setq org-export-with-drawers '("HIDE"))
  (setq org-export-with-sub-superscripts nil)
  (setq org-export-with-tags 'not-in-toc)
  (setq org-export-with-timestamps t)
  (setq org-export-with-toc nil)
  (setq org-export-with-priority t)
  (setq org-export-dispatch-use-expert-ui t)
  (setq org-export-babel-evaluate t)
  (setq org-export-allow-bind-keywords t)
  (setq org-publish-list-skipped-files nil)
  (setq org-fast-tag-selection-single-key 'expert)
  (setq org-fontify-done-headline t)
  (setq org-footnote-auto-label 'confirm)
  (setq org-footnote-auto-adjust t)
  (setq org-hide-emphasis-markers t)
  (setq org-hide-macro-markers t)
  (setq org-icalendar-include-todo 'all)
  (setq org-link-frame-setup '((gnus . gnus) (file . find-file-other-window)))
  (setq org-log-note-headings
    '((done . "CLOSING NOTE %t") (state . "State %-12s %t") (clock-out . "")))
  (setq org-footnote-section "Notes")
  (setq org-attach-directory "~/.Org/data/")
  (setq org-link-display-descriptive nil)
  (setq org-export-filter-planning-functions
        '(MatttLu/org-html-export-planning))
  (setq org-export-with-broken-links t)
#+END_SRC

*** Exporting to HTML

Don't include a footer with my contact and publishing information at the bottom
of every exported HTML document.

#+BEGIN_SRC emacs-lisp
  (setq org-html-head "")
  (setq org-html-head-include-default-style nil)
  (setq org-html-postamble nil)
  (setq org-html-table-row-tags
	(cons '(cond (top-row-p "<tr class=\"tr-top\">")
		     (bottom-row-p "<tr class=\"tr-bottom\">")
		     (t (if (= (mod row-number 2) 1)
			    "<tr class=\"tr-odd\">"
			  "<tr class=\"tr-even\">")))
	      "</tr>"))
  (setq org-gnus-prefer-web-links nil)
  (setq org-html-head-include-default-style nil)
  (setq org-html-head-include-scripts nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun MattLu/org-html-export-planning (planning-string backend info)
    (when (string-match "<p>.+><\\([0-9]+-[0-9]+-[0-9]+\\)[^>]+><.+</p>" planning-string)
      (concat "<span class=\"planning\">" (match-string 1 planning-string) "</span>")))
#+END_SRC

Exporting to HTML and opening the results triggers =/usr/bin/sensible-browser=,
which checks the =$BROWSER= environment variable to choose the right browser.
I'd like to always use Firefox, so:

#+BEGIN_SRC emacs-lisp
  (setenv "BROWSER" "safari")
#+END_SRC

*** Exporting to PDF

I want to produce PDFs with syntax highlighting in the code. The best way to do
that seems to be with the =minted= package, but that package shells out to
=pygments= to do the actual work. =pdflatex= usually disallows shell commands;
this enables that.

#+BEGIN_SRC emcs-lisp
  (setq org-latex-listings t)
  (add-to-list 'org-latex-classes
	       '("my-letter"
		 "\\documentclass\{scrlttr2\}
	      \\usepackage[english,frenchb]{babel}
	      \[NO-DEFAULT-PACKAGES]
	      \[NO-PACKAGES]
	      \[EXTRA]"))
#+END_SRC


#+BEGIN_SRC emacs-lisp
  (setq org-latex-pdf-process
        '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

Include the =minted= package in all of my LaTeX exports.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-latex-listings 'minted)
#+END_SRC

** COMMENT org-caldav

#+BEGIN_SRC emacs-lisp
  (use-package org-caldav)

  (defun MattLu/caldav-sync-perso ()
    (interactive)
    (let ((org-caldav-inbox (org-file-path "rdv.org"))
          (org-caldav-calendar-id "personnel")
          (org-caldav-url "Google")
          (org-caldav-files nil))
      (call-interactively 'org-caldav-sync)))

  (defun MattLu/caldav-sync-etalab-perso ()
    (interactive)
    (let ((org-caldav-inbox "~/.Org/rdv-etalab.org")
          (org-caldav-calendar-id "personal")
          (org-caldav-url "Outlook")
          (org-caldav-files nil))
      (call-interactively 'org-caldav-sync)))

  (defun MattLu/etalab-caldav-sync ()
    (interactive)
    (MattLu/caldav-sync-etalab-perso))

  (defun bzg-caldav-sync-all ()
    (interactive)
    (MattLu/etalab-caldav-sync)
    (MattLu/caldav-sync-perso))
#+END_SRC
* Writing thesis

 Write raw LaTex document using [[https://www.gnu.org/software/auctex/][auctex]]

#+BEGIN_SRC emacs-lisp
  (use-package auctex
    :defer t
    :ensure t
    :config
    (setq TeX-auto-save t)
    (setq TeX-parse-self t)
    (setq-default TeX-master nil)
    (add-hook 'LaTeX-mode-hook 'visual-line-mode)
    (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
    (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
    (setq reftex-plug-into-AUCTeX t))
#+END_SRC


#+BEGIN_SRC emacs-lisp
  (use-package company-auctex
    :config
    (add-hook 'TeX-mode-hook
              (lambda ()
                (make-local-variable 'company-backends)
                (company-auctex-init))))
#+END_SRC

** Set some usefull commands of latex

 #+BEGIN_SRC emacs-lisp
   (eval-after-load "tex"
     '(setq TeX-command-list
                   '(("XeLaTeX_SyncteX" "%`xelatex --synctex=1%(mode)%' %t" TeX-run-TeX nil
                      (latex-mode doctex-mode)
                      :help "Run XeLaTeX")
                     ("TeX" "%(PDF)%(tex) %`%S%(PDFout)%(mode)%' %t" TeX-run-TeX nil
                      (plain-tex-mode texinfo-mode ams-tex-mode)
                      :help "Run plain TeX")
                     ("LaTeX" "%`%l%(mode)%' %t" TeX-run-TeX nil
                      (latex-mode doctex-mode)
                      :help "Run LaTeX")
                     ("Makeinfo" "makeinfo %t" TeX-run-compile nil
                      (texinfo-mode)
                      :help "Run Makeinfo with Info output")
                     ("Makeinfo HTML" "makeinfo --html %t" TeX-run-compile nil
                      (texinfo-mode)
                      :help "Run Makeinfo with HTML output")
                     ("AmSTeX" "%(PDF)amstex %`%S%(PDFout)%(mode)%' %t" TeX-run-TeX nil
                      (ams-tex-mode)
                      :help "Run AMSTeX")
                     ("ConTeXt" "texexec --once --texutil %(execopts)%t" TeX-run-TeX nil
                      (context-mode)
                      :help "Run ConTeXt once")
                     ("ConTeXt Full" "texexec %(execopts)%t" TeX-run-TeX nil
                      (context-mode)
                      :help "Run ConTeXt until completion")
                     ("BibTeX" "bibtex %s" TeX-run-BibTeX nil t
                      :help "Run BibTeX")
                     ("View" "%V" TeX-run-discard-or-function nil t
                      :help "Run Viewer")
                     ("Print" "%p" TeX-run-command t t
                      :help "Print the file")
                     ("Queue" "%q" TeX-run-background nil t
                      :help "View the printer queue" :visible TeX-queue-command)
                     ("File" "%(o?)dvips %d -o %f " TeX-run-command t t
                      :help "Generate PostScript file")
                     ("Index" "makeindex %s" TeX-run-command nil t
                      :help "Create index file")
                     ("Check" "lacheck %s" TeX-run-compile nil
                      (latex-mode)
                      :help "Check LaTeX file for correctness")
                     ("Spell" "(TeX-ispell-document \"\")" TeX-run-function nil t
                      :help "Spell-check the document")
                     ("Clean" "TeX-clean" TeX-run-function nil t
                      :help "Delete generated intermediate files")
                     ("Clean All" "(TeX-clean t)" TeX-run-function nil t
                      :help "Delete generated intermediate and output files")
                     ("Other" "" TeX-run-command t t
                      :help "Run an arbitrary command")
                     ("Jump to PDF" "%V" TeX-run-discard-or-function nil t
                      :help "Run Viewer")
                     ("TeXcount" "texcount %s.tex" TeX-run-compile nil t
                      :help "Run texcount")
                     ) ))
 #+END_SRC

** Enable forward and inverse search

 #+BEGIN_SRC emacs-lisp
  (setq TeX-source-correlate-method (quote synctex))
  (setq TeX-source-correlate-mode t)
  (setq TeX-source-correlate-start-server t)
 #+END_SRC

** Set pdf viewer

 #+BEGIN_SRC emacs-lisp
   (setq TeX-view-program-selection  '((output-pdf "PDF Viewer")))
   (setq TeX-view-program-list
         '(("PDF Viewer" "/Applications/Skim.app/Contents/SharedSupport/displayline -b -g %n %o %b")))
 #+END_SRC

** Set [[https://www.gnu.org/software/auctex/reftex.html][reftex]]  References, labels, citations

 #+BEGIN_SRC emacs-lisp
;;   (use-package org-ref)
   (add-hook 'LaTeX-mode-hook 'turn-on-reftex) ; with Auctex Latex mode
   (add-hook 'latex-mode-hook 'turn-on-reftex) ; with Emacs latex mode
   (setq reftex-plug-into-AUCTeX t)
 #+END_SRC

* =dired=

Open media with the appropriate programs.

#+BEGIN_SRC emacs-lisp
  (use-package dired-open
    :config
    (setq dired-open-extensions
          '(("pdf" . "evince")
            ("mkv" . "mpv")
            ("mp4" . "mpv")
            ("avi" . "mpv"))))
#+END_SRC

These are the switches that get passed to =ls= when =dired= gets a list of
files. We're using:

- =l=: Use the long listing format.
- =h=: Use human-readable sizes.
- =v=: Sort numbers naturally.
- =A=: Almost all. Doesn't include "=.=" or "=..=".

#+BEGIN_SRC emacs-lisp
  (setq-default dired-listing-switches "-lhvA")
#+END_SRC

Use “[” and “]” to jump out and in dired.

#+BEGIN_SRC emacs-lisp
  (eval-after-load "dired"
    '(progn
       (define-key dired-mode-map (kbd "[") 'dired-up-directory)
       (define-key dired-mode-map (kbd "]") 'dired-open-file)))
  (eval-after-load "view"
    '(define-key view-mode-map (kbd "[") 'View-quit))
#+END_SRC

fast copy and past

#+BEGIN_SRC emacs-lisp
  (setq dired-dwim-target t)
#+END_SRC

Kill buffers of files/directories that are deleted in =dired=.

#+BEGIN_SRC emacs-lisp
  (setq dired-clean-up-buffers-too t)
#+END_SRC

Always copy directories recursively instead of asking every time.

#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-copies 'always)
#+END_SRC

Ask before recursively /deleting/ a directory, though.

#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-deletes 'top)
#+END_SRC

Files are normally moved and copied synchronously.
This is fine for small or local files,
but copying a large file or moving a file across a mounted
network drive blocks Emacs until the process is completed. Unacceptable!

This uses =emacs-async= to make dired perform actions asynchronously.

#+begin_src emacs-lisp
  (use-package async
    :config
    (dired-async-mode 1))
#+end_src

reuse dired buffer
#+begin_src emacs-lisp
  (put 'dired-find-alternate-file 'disabled nil)
#+end_src

* Editing settings
** Hydra

#+begin_src emacs-lisp
  (use-package hydra)
#+end_src

** Quickly visit Emacs
configuration

I futz around with my dotfiles a lot. This binds =C-c e= to quickly open my
Emacs configuration file.

#+BEGIN_SRC emacs-lisp
  (defun MattLu/visit-emacs-config ()
    (interactive)
    (find-file "~/.emacs.d/configuration.org"))

  (global-set-key (kbd "C-c e") 'MattLu/visit-emacs-config)
#+END_SRC

** Always kill current buffer

Assume that I always want to kill the current buffer when hitting =C-x k=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x k") 'MattLu/kill-current-buffer)
#+END_SRC

** Set up =helpful=

The =helpful= package provides, among other things, more context in Help
buffers.

#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :bind
    (("C-h f" . helpful-callable)
     ("C-h v" . helpful-variable)
     ("C-h k" . helpful-key)))
#+END_SRC

** Look for executables in =/usr/local/bin=.

Add system path to emacs.

#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'darwin)
      (mapcar #'MattLu/append-to-path
              '("/usr/local/bin"
                "/Library/TeX/texbin"
                "/usr/local/opt/llvm/bin/")))
#+END_SRC

** Always indent with spaces

Never use tabs. Tabs are the devil’s whitespace.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

** Install and configure which-key

which-key displays the possible completions for a long keybinding. That’s really helpful
for some modes (like projectile, for example).

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config (which-key-mode))
#+END_SRC

** Configure yasnippet

I keep my snippets in =~/.emacs/snippets/text-mode=, and I always want =yasnippet=
enabled.

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :config
    (use-package yasnippet-snippets)
    (yas-global-mode 1))
#+END_SRC

I /don’t/ want =ido= to automatically indent the snippets it inserts. Sometimes
this looks pretty bad (when indenting org-mode, for example, or trying to guess
at the correct indentation for Python).

#+BEGIN_SRC emacs-lisp
  (setq yas/indent-line nil)
#+END_SRC

** ivy + counsel + swiper

  ivy configuration
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :config
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t
          ivy-count-format "%d/%d "
          enable-recursive-minibuffers t)
    (setq ivy-initial-inputs-alist nil)
    (setq ivy-re-builders-alist
      '((swiper . ivy--regex-plus)
        (t . ivy--regex-fuzzy)))
    (setq ivy-do-completion-in-region nil)
    :requires flx)
#+END_SRC

   counsel configuration (counsel package replay on swiper)

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :bind
    ("C-s" . 'swiper)
    ("M-x" . 'counsel-M-x)
    ("C-x C-f" . 'counsel-find-file)
    ("M-y" . 'counsel-yank-pop)
    ("C-x b" . 'ivy-switch-buffer)
    ("C-c k" . 'counsel-rg)
    ("C-x C-b" . 'ibuffer)
    ("C-c C-r" . 'ivy-resume)
    ("C-c b" . 'counsel-bookmark)
    ("C-c d" . 'counsel-descbinds)
    ("C-c f" . 'counsel-recentf)
    :config
    (use-package flx)
    (use-package smex))
#+END_SRC

   better information for ivy switch buffer
#+BEGIN_SRC emacs-lisp
  (use-package ivy-rich
    :after (ivy)
    :config
    (setq ivy-initial-inputs-alist nil)
    (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
    (plist-put ivy-rich-display-transformers-list
               'ivy-switch-buffer
               '(:columns
                 ((ivy-rich-candidate (:width 50))
                  (ivy-rich-switch-buffer-size (:width 7))
                  (ivy-rich-switch-buffer-indicators (:width 4 :face error :align right))
                  (ivy-rich-switch-buffer-major-mode (:width 18 :face warning))
                  (ivy-rich-switch-buffer-project (:width 20 :face success))
                  (ivy-rich-switch-buffer-path
                   (:width (lambda (x) (ivy-rich-switch-buffer-shorten-path x (ivy-rich-minibuffer-width 0.3))))))
                 :predicate
                 (lambda (cand) (get-buffer cand))))
    (plist-put ivy-rich-display-transformers-list
               'counsel-bookmark
               '(:columns
                 ((ivy-rich-bookmark-type (:width 10))
                  (ivy-rich-candidate (:width 60))
                  (ivy-rich-bookmark-info
                   (:width (lambda (x) (ivy-rich-switch-buffer-shorten-path x (ivy-rich-minibuffer-width 0.3))))))))
    (ivy-rich-mode 1)
    (setq ivy-rich-path-style 'abbrev))
#+END_SRC

*** override ivy-thing-at-point

ivy-thing-at-point call ffap-file-at-point then call comint-output-filter
:Profile-Report:
- ivy-completing-read                               140,189,606  88%
 - ivy-read                                         140,189,606  88%
  - ivy--reset-state                                140,189,606  88%
   - ivy-thing-at-point                             140,165,054  88%
    - ffap-file-at-point                            140,072,938  88%
     - python-ffap-module-path                      140,067,818  88%
      - python-shell-send-string-no-output          140,067,818  88%
       - accept-process-output                      137,134,284  86%
        - comint-output-filter                      136,924,775  86%
         + python-shell-output-filter                 4,601,423   2%
:END:
but right now I will change ivy.el instead

#+BEGIN_SRC emacs-lisp
  (defun ivy-thing-at-point()
    nil)
#+END_SRC

** Switch and rebalance windows when splitting

When splitting a window, I invariably want to switch to the new window. This
makes that automatic.

#+BEGIN_SRC emacs-lisp
  (defun MattLu/split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun MattLu/split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))

 ; (global-set-key (kbd "C-x 2") 'MattLu/split-window-below-and-switch)
 ; (global-set-key (kbd "C-x 3") 'MattLu/split-window-right-and-switch)
#+END_SRC

** Mass editing of =grep= results

I like the idea of mass editing =grep= results the same way I can edit filenames
in =dired=. These keybindings allow me to use =C-x C-q= to start editing =grep=
results and =C-c C-c= to stop, just like in =dired=.

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'grep
    '(define-key grep-mode-map
      (kbd "C-x C-q") 'wgrep-change-to-wgrep-mode))

  (eval-after-load 'wgrep
    '(define-key grep-mode-map
      (kbd "C-c C-c") 'wgrep-finish-edit))

  (setq wgrep-auto-save-buffer t)
#+END_SRC

** Configure =wrap-region=

warp selected region with punctuate.

#+BEGIN_SRC emacs-lisp
  (use-package wrap-region
    :config
    (wrap-region-global-mode t)
    (wrap-region-add-wrappers
     '(("$" "$")
       ("/" "/" nil ruby-mode)
       ("/* " " */" "#" (java-mode javascript-mode css-mode))
       ("`" "`" nil (markdown-mode ruby-mode)))))
#+END_SRC

** COMMENT Use projectile everywhere

#+BEGIN_SRC emacs-lisp
  (projectile-mode)
#+END_SRC

** Use multiple cursors

Set multiple cursors for better marker words

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
   :bind ("C-S-c C-S-c" . mc/edit-lines)
         ("C->" . mc/mark-next-like-this)
         ("C-<" . mc/mark-previous-like-this)
         ("C-c C-<"  . mc/mark-all-like-this))
#+END_SRC

** Use expand region

Expand region increases the selected region by semantic units.
Just keep pressing the key until it selects what you want.

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
   :bind  ("C-c q" . er/expand-region))
#+END_SRC

** Use ace-jump

Use ace-jump-mode to quick jump to words or char

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :bind
    ("C-c j" . avy-goto-word-or-subword-1)
    ("C-'"   . avy-goto-char-timer)
    ("M-g f" . avy-goto-line)
    :config
    (setq avy-all-windows nil)
    (setq avy-background t)
    (setq avy-timeout-seconds 0.3)
    (unbind-key "C-'" org-mode-map)) ;; jump in current frame
#+END_SRC

** Scrolling one line

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-S-n") "\C-u1\C-v")
  (global-set-key (kbd "C-S-p") "\C-u1\M-v")
#+END_SRC

** Use goto-last-change to jump between

#+BEGIN_SRC emacs-lisp
  (use-package goto-chg
    :config
    (bind-keys* ("C-." . goto-last-change))
    (bind-keys* ("C-," . goto-last-change-reverse)))
#+END_SRC

** windows switch

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind
    ("M-o" . 'ace-window)
    ("C-x o" . 'ace-window)
    :config
    (setq aw-scope 'frame)   ; only the windows of the current frame
    (setq aw-background t)
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+END_SRC

** Handle layer file

#+BEGIN_SRC emacs-lisp
  (setq fast-but-imprecise-scrolling t)
#+END_SRC

** suppress undo overflow

This is normal if you executed a command that made a huge change
to the buffer.  In that case, to prevent similar problems in the
future, set `undo-outer-limit' to a value that is large enough to
cover the maximum size of normal changes you expect a single
command to make, but not so large that it might exceed the
maximum memory allotted to Emacs.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'warning-suppress-types '(undo discard-info))
#+END_SRC

** COMMENT Increase a bit garbage collection threshold

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 1600000)
#+END_SRC

** using too-long-lines-mode to discard extremely long lines

#+BEGIN_SRC emacs-lisp
  (use-package too-long-lines-mode
    ;; using use-package PATH
    :load-path "~/.emacs.d/too-long-lines-mode"
    ;; using quelpa URL
    ;; :quelpa
    ;; ((too-long-lines-mode
    ;;   :fetcher github
    ;;   :repo "rakete/too-long-lines-mode")
    ;;  :upgrade t)
    :config
    (set 'too-long-lines-special-buffer-modes
         '(shell-mode ag-mode inferior-python-mode comint-mode))
    (too-long-lines-mode))
#+END_SRC

** fast scroll

To ensure scrolling is fast in Emacs, I use a package that disables
non-essential things while the window is being scrolled

#+BEGIN_SRC emacs-lisp
  (use-package fast-scroll
    :config
    (add-hook 'fast-scroll-start-hook
              (lambda ()
                (flyspell-mode -1)))
    (add-hook 'fast-scroll-end-hook
              (lambda ()
                (flyspell-mode 1)))
    (fast-scroll-config)
    (fast-scroll-mode 1))
#+END_SRC

** jump back and forth

 back-button offers local and global jumping

#+begin_src emacs-lisp
  (use-package back-button
    :bind (:map back-button-mode-map
                ("C-<right>" . hydra-back-and-forth/back-button-local-forward)
                ("C-<left>" . hydra-back-and-forth/back-button-local-backward)
                ("C-<up>" . hydra-back-and-forth/back-button-global-backward)
                ("C-<down>" . hydra-back-and-forth/back-button-global-forward))
    :init
    (back-button-mode 1)
    (define-key back-button-mode-map (kbd "C-x <C-left>") nil)
    (define-key back-button-mode-map (kbd "C-x <C-right>") nil)
    (define-key back-button-mode-map (kbd "C-x <left>") nil)
    (define-key back-button-mode-map (kbd "C-x <right>") nil)
    (define-key back-button-mode-map (kbd "C-x C-SPC") nil)
    (define-key back-button-mode-map (kbd "C-x SPC") nil)
    :config
    (defhydra hydra-back-and-forth ()
      "back-and-forth"
      ("<right>" back-button-local-forward "→")
      ("<left>" back-button-local-backward "←")
      ("<up>" back-button-global-backward "↑")
      ("<down>" back-button-global-forward "↓"))
    :after (hydra))
#+end_src

** Ediff

I like Ediff's control panel to show in the same frame, even on
graphical environments.

#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC
** COMMENT Icicles

#+begin_src emacs-lisp
  (use-package icicles
    :quelpa
    ((icicles
      :fetcher github
      :repo "emacsmirror/icicles")
     :upgrade t)
    :config
    (icy-mode 1))
#+end_src

* Set custom keybindings

Just a few handy functions.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-/") 'hippie-expand)
#+END_SRC

Remap when working in terminal Emacs.

#+BEGIN_SRC emacs-lisp
  (define-key input-decode-map "\e[1;2A" [S-up])
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq ns-right-option-modifier 'super)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-_") 'undo)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c w") 'ediff-regions-wordwise)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (global-unset-key (kbd "C-x 5 1"))
  (local-unset-key (kbd "C-x 5 1"))
#+END_SRC
