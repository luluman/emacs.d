#+TITLE: Emacs Configuration
#+ORIGNAL:Harry R. Schwartz
#+AUTHOR: MattLu
#+EMAIL: lu.man@outlook.com
#+OPTIONS: toc:nil num:nil
[[https://github.com/hrs/dotfiles][Harry R. Schwartz]]
* Use sensible-defaults.el

Use [[https://github.com/hrs/sensible-defaults.el][sensible-defaults.el]] for some basic settings.

#+BEGIN_SRC emacs-lisp
  (load-file "./.emacs.d/sensible-defaults.el")
  (sensible-defaults/use-all-settings)
  (sensible-defaults/use-all-keybindings)
  (sensible-defaults/backup-to-temp-directory)
#+END_SRC

* Configure =use-package=

I'm currently using Cask to manage my dependencies, but I'm gradually moving to
=use-package=. I'm planning on converting packages lazily, as I need them, so
expect to see a somewhat inconsistent state for a while. =)

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (setq use-package-verbose t)
  (setq use-package-always-ensure t)

  (require 'use-package)
#+END_SRC

Always compile packages, and use the newest version available.

#+BEGIN_SRC emacs-lisp
  (use-package auto-compile
    :config (auto-compile-on-load-mode))
  (setq load-prefer-newer t)
#+END_SRC

* Set personal information

** Who am I? Where am I?

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "MattLu"
        user-mail-address "lu.man@outlook.com"
        calendar-latitude 39.97
        calendar-longitude 116.34
        calendar-location-name "zhongkeyuanQingniangongyu H2209")
#+END_SRC

** COMMENT Access my netrc data

#+BEGIN_SRC emacs-lisp
  (require 'netrc)

  (setq netrc-file "~/.netrc")

  (defun netrc-username (machine)
    "Helper function to extract a username from my netrc."
    (car (netrc-credentials machine)))

  (defun netrc-password (machine)
    "Helper function to extract a password from my netrc."
    (cadr (netrc-credentials machine)))
#+END_SRC

* COMMENT Add =resources= to =load-path=

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/resources/")
#+END_SRC

* COMMENT =evil-mode=

I'd prefer not to expand abbrevs when I hit escape. That's always jarring and
usually not what I want. In particular, it makes working with Coq really
frustrating.

#+BEGIN_SRC emacs-lisp
  (setq evil-want-abbrev-expand-on-insert-exit nil)
#+END_SRC

Use =evil=.

#+BEGIN_SRC emacs-lisp
  (evil-mode 1)
#+END_SRC

Enable =surround= everywhere.

#+BEGIN_SRC emacs-lisp
  (global-evil-surround-mode 1)
#+END_SRC

Bind =C-p= to fuzzy-finding files in the current project.

#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "C-p") 'projectile-find-file)
#+END_SRC

* Utility functions

Define a big ol' bunch of handy utility functions.

#+BEGIN_SRC emacs-lisp
  (defun MattLu/view-buffer-name ()
    "Display the filename of the current buffer."
    (interactive)
    (message (buffer-file-name)))

  (defun MattLu/rename-file (new-name)
    (interactive "FNew name: ")
    (let ((filename (buffer-file-name)))
      (if filename
          (progn
            (when (buffer-modified-p)
               (save-buffer))
            (rename-file filename new-name t)
            (kill-buffer (current-buffer))
            (find-file new-name)
            (message "Renamed '%s' -> '%s'" filename new-name))
        (message "Buffer '%s' isn't backed by a file!" (buffer-name)))))

  (defun MattLu/generate-scratch-buffer ()
    "Create and switch to a temporary scratch buffer with a random
       name."
    (interactive)
    (switch-to-buffer (make-temp-name "scratch-")))

  (defun MattLu/de-unicode ()
    "Tidy up a buffer by replacing all special Unicode characters
       (smart quotes, etc.) with their more sane cousins"
    (interactive)
    (let ((unicode-map '(("[\u2018\|\u2019\|\u201A\|\uFFFD]" . "'")
                         ("[\u201c\|\u201d\|\u201e]" . "\"")
                         ("\u2013" . "--")
                         ("\u2014" . "---")
                         ("\u2026" . "...")
                         ("\u00A9" . "(c)")
                         ("\u00AE" . "(r)")
                         ("\u2122" . "TM")
                         ("[\u02DC\|\u00A0]" . " "))))
      (save-excursion
        (loop for (key . value) in unicode-map
              do
              (goto-char (point-min))
              (replace-regexp key value)))))

  (defun MattLu/beautify-json ()
    "Pretty-print the JSON in the marked region. Currently shells
       out to `jsonpp'--be sure that's installed!"
    (interactive)
    (save-excursion
      (shell-command-on-region (mark) (point) "jsonpp" (buffer-name) t)))

  (defun MattLu/unfill-paragraph ()
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive)
    (let ((fill-column (point-max)))
      (fill-paragraph nil)))

  (defun MattLu/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (defun MattLu/visit-last-dired-file ()
    "Open the last file in an open dired buffer."
    (end-of-buffer)
    (previous-line)
    (dired-find-file))

  (defun MattLu/visit-last-migration ()
    "Open the last file in 'db/migrate/'. Relies on projectile. Pretty sloppy."
    (interactive)
    (dired (expand-file-name "db/migrate" (projectile-project-root)))
    (MattLu/visit-last-dired-file)
    (kill-buffer "migrate"))

  (defun MattLu/add-auto-mode (mode &rest patterns)
    "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
    (dolist (pattern patterns)
      (add-to-list 'auto-mode-alist (cons pattern mode))))

  (defun MattLu/find-file-as-sudo ()
    (interactive)
    (let ((file-name (buffer-file-name)))
      (when file-name
        (find-alternate-file (concat "/sudo::" file-name)))))

  (defun MattLu/region-or-word ()
    (if mark-active
        (buffer-substring-no-properties (region-beginning)
                                        (region-end))
      (thing-at-point 'word)))

  (defun MattLu/insert-random-string (len)
    "Insert a random alphanumeric string of length len."
    (interactive)
    (let ((mycharset "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstyvwxyz"))
      (dotimes (i len)
        (insert (elt mycharset (random (length mycharset)))))))

  (defun MattLu/generate-password ()
    "Insert a good alphanumeric password of length 30."
    (interactive)
    (MattLu/insert-random-string 30))

  (defun MattLu/append-to-path (path)
    "Add a path both to the $PATH variable and to Emacs' exec-path."
    (setenv "PATH" (concat (getenv "PATH") ":" path))
    (add-to-list 'exec-path path))
#+END_SRC

* UI preferences
** Tweak window chrome

I don't usually use the menu or scroll bar, and they take up useful space.

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (when window-system
    (scroll-bar-mode -1))
#+END_SRC

The default frame title isn't useful. This binds it to the name of the current
project:

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format '((:eval (projectile-project-name))))
#+END_SRC

** Use fancy lambdas

Why not?

#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode t)
#+END_SRC

** Custom solarized-dark theme

I like the solarized-dark theme. I prefer keeping all the characters in the same
side and font, though.

#+BEGIN_SRC emacs-lisp
  (defun MattLu/apply-solarized-theme ()
    (setq solarized-use-variable-pitch nil)
    (setq solarized-height-plus-1 1.0)
    (setq solarized-height-plus-2 1.0)
    (setq solarized-height-plus-3 1.0)
    (setq solarized-height-plus-4 1.0)
    (setq solarized-high-contrast-mode-line t)
    (load-theme 'solarized-dark t)) ;;light
#+END_SRC

If this code is being evaluated by =emacs --daemon=, ensure that each subsequent
frame is themed appropriately.

#+BEGIN_SRC emacs-lisp
  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame)
                    (MattLu/apply-solarized-theme)))
    (MattLu/apply-solarized-theme))
#+END_SRC

** COMMENT Disable visual bell

=sensible-defaults= replaces the audible bell with a visual one, but I really
don't even want that (and my Emacs/Mac pair renders it poorly). This disables
the bell altogether.

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

** Scroll conservatively

When point goes outside the window, Emacs usually recenters the buffer point.
I'm not crazy about that. This changes scrolling behavior to only scroll as far
as point goes.

#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC

** Set default font and configure font resizing

I'm partial to Inconsolata.

The standard =text-scale-= functions just resize the text in the current buffer;
I'd generally like to resize the text in /every/ buffer, and I usually want to
change the size of the modeline, too (this is especially helpful when
presenting). These functions and bindings let me resize everything all together!

Note that this overrides the default font-related keybindings from
=sensible-defaults=.

#+BEGIN_SRC emacs-lisp
    (setq MattLu/default-font "Inziu IosevkaCC SC")
    (setq MattLu/default-font-size 12)
    (setq MattLu/current-font-size MattLu/default-font-size)

    (setq MattLu/font-change-increment 1.1)

    (defun MattLu/font-code ()
      "Return a string representing the current font (like \"Inconsolata-14\")."
      (concat MattLu/default-font "-" (number-to-string MattLu/current-font-size)))

    (defun MattLu/set-font-size ()
      "Set the font to `MattLu/default-font' at `MattLu/current-font-size'.
    Set that for the current frame, and also make it the default for
    other, future frames."
      (let ((font-code (MattLu/font-code)))
        (add-to-list 'default-frame-alist (cons 'font font-code))
        (set-frame-font font-code)))

    (defun MattLu/reset-font-size ()
      "Change font size back to `MattLu/default-font-size'."
      (interactive)
      (setq MattLu/current-font-size MattLu/default-font-size)
      (MattLu/set-font-size))

    (defun MattLu/increase-font-size ()
      "Increase current font size by a factor of `MattLu/font-change-increment'."
      (interactive)
      (setq MattLu/current-font-size
            (ceiling (* MattLu/current-font-size MattLu/font-change-increment)))
      (MattLu/set-font-size))

    (defun MattLu/decrease-font-size ()
      "Decrease current font size by a factor of `MattLu/font-change-increment', down to a minimum size of 1."
      (interactive)
      (setq MattLu/current-font-size
            (max 1
                 (floor (/ MattLu/current-font-size MattLu/font-change-increment))))
      (MattLu/set-font-size))

    (define-key global-map (kbd "C-)") 'MattLu/reset-font-size)
    (define-key global-map (kbd "C-+") 'MattLu/increase-font-size)
  ;;  (define-key global-map (kbd "C-=") 'MattLu/increase-font-size)
    (define-key global-map (kbd "C-_") 'MattLu/decrease-font-size)
  ;; (define-key global-map (kbd "C--") 'MattLu/decrease-font-size)
   (define-key global-map (kbd "C--") nil)

    (MattLu/reset-font-size)
#+END_SRC


** Highlight the current line

=global-hl-line-mode= softly highlights the background color of the line
containing point. It makes it a bit easier to find point, and it's useful when
pairing or presenting code.

#+BEGIN_SRC emacs-lisp
  (when window-system
    (global-hl-line-mode))
#+END_SRC

** Hide certain modes from the modeline

I'd rather have only a few necessary mode identifiers on my modeline. This
either hides or "renames" a variety of major or minor modes using the =diminish=
package.

#+BEGIN_SRC emacs-lisp
  (defmacro diminish-minor-mode (filename mode &optional abbrev)
    `(eval-after-load (symbol-name ,filename)
       '(diminish ,mode ,abbrev)))

  (defmacro diminish-major-mode (mode-hook abbrev)
    `(add-hook ,mode-hook
               (lambda () (setq mode-name ,abbrev))))

  (diminish-minor-mode 'abbrev 'abbrev-mode)
  (diminish-minor-mode 'simple 'auto-fill-function)
  (diminish-minor-mode 'company 'company-mode)
  (diminish-minor-mode 'eldoc 'eldoc-mode)
  (diminish-minor-mode 'flycheck 'flycheck-mode)
  (diminish-minor-mode 'flyspell 'flyspell-mode)
  (diminish-minor-mode 'global-whitespace 'global-whitespace-mode)
  (diminish-minor-mode 'projectile 'projectile-mode)
  (diminish-minor-mode 'ruby-end 'ruby-end-mode)
  (diminish-minor-mode 'subword 'subword-mode)
  (diminish-minor-mode 'undo-tree 'undo-tree-mode)
  (diminish-minor-mode 'yard-mode 'yard-mode)
  (diminish-minor-mode 'yasnippet 'yas-minor-mode)
  (diminish-minor-mode 'wrap-region 'wrap-region-mode)

  (diminish-minor-mode 'paredit 'paredit-mode " π")

  (diminish-major-mode 'emacs-lisp-mode-hook "el")
  (diminish-major-mode 'haskell-mode-hook "λ=")
  (diminish-major-mode 'lisp-interaction-mode-hook "λ")
  (diminish-major-mode 'python-mode-hook "Py")
#+END_SRC

** Highlight uncommitted changes

Use the =diff-hl= package to highlight changed-and-uncommitted lines when
programming.

#+BEGIN_SRC emacs-lisp
  (require 'diff-hl)

  (add-hook 'prog-mode-hook 'turn-on-diff-hl-mode)
  (add-hook 'vc-dir-mode-hook 'turn-on-diff-hl-mode)
#+END_SRC

** Change frame apperience

Change the frame alpha .

#+BEGIN_SRC emacs-lisp
  (defun MattLu/change-frame-alpha ()
    (set-frame-parameter (selected-frame) 'alpha '(96 96))
    (add-to-list 'default-frame-alist '(alpha 96 96)))
#+END_SRC

If emacs shwo on GUI, than apply this code.

#+BEGIN_SRC emacs-lisp
  (if (display-graphic-p)
      (MattLu/change-frame-alpha))
#+END_SRC

* Programming customizations

I like shallow indentation, but tabs are displayed as 8 characters by default.
This reduces that.

#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 2)
#+END_SRC

Treating terms in CamelCase symbols as separate words makes editing a little
easier for me, so I like to use =subword-mode= everywhere.

#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC

Compilation output goes to the =*compilation*= buffer. I rarely have that window
selected, so the compilation output disappears past the bottom of the window.
This automatically scrolls the compilation window so I can always see the
output.

#+BEGIN_SRC emacs-lisp
  (setq compilation-scroll-output t)
#+END_SRC


** Coq

Use =company-coq-mode=, which really helps make Proof General a more useful IDE.

I also like to disable =abbrev-mode=; it has a ton of abbreviations for Coq, but
they've always been unpleasant surprises for me.

#+BEGIN_SRC emacs-lisp
  (add-hook 'coq-mode-hook
            (lambda ()
              (company-coq-mode)
              (abbrev-mode 0)))
#+END_SRC

The default Proof General layout stacks the code, goal, and response buffers on
top of each other. I like to keep my code on one side and my goal and response
buffers on the other.

#+BEGIN_SRC emacs-lisp
  (setq proof-three-window-mode-policy 'hybrid)
#+END_SRC

The Proof General splash screen's pretty cute, but I don't need to see it every
time.

#+BEGIN_SRC emacs-lisp
  (setq proof-splash-enable nil)
#+END_SRC

** COMMENT CSS and Sass

Indent 2 spaces and use =rainbow-mode= to display color-related words in the
color they describe.

#+BEGIN_SRC emacs-lisp
  (add-hook 'css-mode-hook
            (lambda ()
              (rainbow-mode)
              (setq css-indent-offset 2)))

  (add-hook 'scss-mode-hook 'rainbow-mode)
#+END_SRC

Don't compile the current file every time I save.

#+BEGIN_SRC emacs-lisp
  (setq scss-compile-at-save nil)
#+END_SRC

** COMMENT Golang

Define my =$GOPATH= and tell Emacs where to find the Go binaries.

#+BEGIN_SRC emacs-lisp
  (setenv "GOPATH" "/home/MattLu/code/go")
  (MattLu/append-to-path (concat (getenv "GOPATH") "/bin"))
#+END_SRC

Run =goimports= on every file when saving, which formats the file and
automatically updates the list of imports. This requires that the =goimports=
binary is installed.

#+BEGIN_SRC emacs-lisp
  (setq gofmt-command "goimports")
  (add-hook 'before-save-hook 'gofmt-before-save)
#+END_SRC

When I open a Go file,

- Start up =company-mode= with the Go backend. This requires that the =gocode=
  binary is installed,
- Redefine the default =compile= command to something Go-specific, and
- Enable =flycheck=.

#+BEGIN_SRC emacs-lisp
  (add-hook 'go-mode-hook
            (lambda ()
              (set (make-local-variable 'company-backends)
                   '(company-go))
              (company-mode)
              (if (not (string-match "go" compile-command))
                  (set (make-local-variable 'compile-command)
                       "go build -v && go test -v && go vet"))
              (flycheck-mode)))
#+END_SRC

** Haskell

Enable =haskell-doc-mode=, which displays the type signature of a function, and
use smart indentation.

#+BEGIN_SRC emacs-lisp
;;  (MattLu/append-to-path "~/.cabal/bin")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'haskell-mode-hook
            (lambda ()
              (haskell-doc-mode)
              (turn-on-haskell-indent)
              (ghc-init)))
#+END_SRC

** JavaScript and CoffeeScript

Indent everything by 2 spaces.

#+BEGIN_SRC emacs-lisp
  (setq js-indent-level 2)

  (add-hook 'coffee-mode-hook
            (lambda ()
              (yas-minor-mode 1)
              (setq coffee-tab-width 2)))
#+END_SRC

** Lisps

All the lisps have some shared features, so we want to do the same things for
all of them. That includes using =paredit-mode= to balance parentheses (and
more!), =rainbow-delimiters= to color matching parentheses, and highlighting the
whole expression when point is on a paren.

#+BEGIN_SRC emacs-lisp
  (setq lispy-mode-hooks
        '(clojure-mode-hook
          emacs-lisp-mode-hook
          lisp-mode-hook
          scheme-mode-hook))

  (dolist (hook lispy-mode-hooks)
    (add-hook hook (lambda ()
                     (setq show-paren-style 'expression)
                     (paredit-mode)
                     (rainbow-delimiters-mode))))
#+END_SRC

If I'm writing in Emacs lisp I'd like to use =eldoc-mode= to display
documentation.

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+END_SRC

My own silly language ([[https://github.com/hrs/blueprint][blueprint]]) is close enough to Scheme that it can use the
same mode.

#+BEGIN_SRC emacs-lisp
  (MattLu/add-auto-mode 'scheme-mode "\\.blu$")
#+END_SRC

** Magit

 I bring up the status menu with =C-x g=:

 #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "C-x g") 'magit-status)
 #+END_SRC

 The default behavior of =magit= is to ask before pushing. I haven't had any
 problems with accidentally pushing, so I'd rather not confirm that every time.

 #+BEGIN_SRC emacs-lisp
   (setq magit-push-always-verify nil)
 #+END_SRC

 Enable spellchecking when writing commit messages:

 #+BEGIN_SRC emacs-lisp
   (add-hook 'git-commit-mode-hook 'turn-on-flyspell)
 #+END_SRC


** COMMENT Prolog

I don't write a lot of Prolog, but (oddly enough) I write more Prolog than Perl.

#+BEGIN_SRC emacs-lisp
  (MattLu/add-auto-mode 'prolog-mode "\\.pl$")
#+END_SRC

** Projectile

Projectile's default binding of =projectile-ag= to =C-c p s s= is clunky enough
that I rarely use it (and forget it when I need it). This binds the
easier-to-type =C-c C-v= and =C-c v= to useful searches.

#+BEGIN_SRC emacs-lisp
  (defun MattLu/search-project-for-symbol-at-point ()
    "Use `projectile-ag' to search the current project for `symbol-at-point'."
    (interactive)
    (projectile-ag (projectile-symbol-at-point)))

  (global-set-key (kbd "C-c v") 'projectile-ag)
  (global-set-key (kbd "C-c C-v") 'MattLu/search-project-for-symbol-at-point)
#+END_SRC

When I visit a project with =projectile-switch-project=, the default action is
to search for a file in that project. I'd rather just open up the top-level
directory of the project in =dired= and find (or create) new files from there.

#+BEGIN_SRC emacs-lisp
  (setq projectile-switch-project-action 'projectile-dired)
#+END_SRC

I'd like to /always/ be able to recursively fuzzy-search for files, not just
when I'm in a Projecile-defined project. This uses the current directory as a
project root (if I'm not in a "real" project).

#+BEGIN_SRC emacs-lisp
  (setq projectile-require-project-root nil)
#+END_SRC

** Python

Set ipython as interpreter

#+BEGIN_SRC emacs-lisp
;  (setq python-shell-interpreter "ipython")
;  (setq python-shell-interpreter-args "--simple-prompt -i")
  (setq py-shell-name "ipython3")
  (setq py-ipython-command-args "--simple-prompt -i")
#+END_SRC


Indent 2 spaces.

#+BEGIN_SRC emacs-lisp
  (setq python-indent 2)
#+END_SRC

Using jedi as python backend

#+BEGIN_SRC emacs-lisp
  (defun MattLu/python-mode-hook ()
    (add-to-list 'company-backends 'company-jedi))
  (add-hook 'python-mode-hook 'MattLu/python-mode-hook)
  (global-set-key (kbd "C-c d") 'jedi:show-doc)
  (setq python-shell-completion-native-enable nil) ;; disable warring in python promote bug
#+END_SRC

** COMMENT Ruby and RSpec

I use =chruby= to switch between versions of Ruby. This sets a default version
to use within Emacs (for things like =xmp= or =rspec=).

#+BEGIN_SRC emacs-lisp
  (chruby "ruby-2.4.0")
#+END_SRC

=rcodetools= provides =xmp=, which lets me evaluate a Ruby buffer and display
the results in "magic" (=# =>=) comments.

I disable warnings in Ruby because I disagree with a few of them (complaining
about private =attr_reader=, especially) and they gunk up my buffer.

#+BEGIN_SRC emacs-lisp
  (setq xmpfilter-command-name
        "ruby -S xmpfilter --no-warnings --dev --fork --detect-rbtest")
  (require 'rcodetools)
#+END_SRC

There are a bunch of things I'd like to do when I open a Ruby buffer:

- I don't want to insert an encoding comment.
- I want to enable =yas=, =rspec=, =yard=, =flycheck=, and =projectile-rails=.
- I'd like my RSpec tests to be run in a random order, and I'd like the output
  to be colored.
- Chruby should automatically determine the correct version for me.
- =C-c C-c= should run =xmp=, to do that nifty "eval into comments" trick.

#+BEGIN_SRC emacs-lisp
  (add-hook 'ruby-mode-hook
            (lambda ()
              (setq ruby-insert-encoding-magic-comment nil)
              (yas-minor-mode)
              (rspec-mode)
              (yard-mode)
              (flycheck-mode)
              (local-set-key "\r" 'newline-and-indent)
              (setq rspec-command-options "--color --order random")
              (chruby-use-corresponding)
              (define-key ruby-mode-map (kbd "C-c C-c") 'xmp)
              (projectile-rails-mode)))
#+END_SRC

I associate =ruby-mode= with Gemfiles, gemspecs, Rakefiles, and Vagrantfiles.

#+BEGIN_SRC emacs-lisp
  (MattLu/add-auto-mode
   'ruby-mode
   "\\Gemfile$"
   "\\.rake$"
   "\\.gemspec$"
   "\\Guardfile$"
   "\\Rakefile$"
   "\\Vagrantfile$"
   "\\Vagrantfile.local$")
#+END_SRC

When running RSpec tests I'd like to scroll to the first error.

#+BEGIN_SRC emacs-lisp
  (add-hook 'rspec-compilation-mode-hook
            (lambda ()
              (make-local-variable 'compilation-scroll-output)
              (setq compilation-scroll-output 'first-error)))
#+END_SRC

** =sh=

Indent with 2 spaces.

#+BEGIN_SRC emacs-lisp
  (add-hook 'sh-mode-hook
            (lambda ()
              (setq sh-basic-offset 2
                    sh-indentation 2)))
#+END_SRC

** COMMENT Slim

If I'm editing Slim templates I'm probably in a Rails project. In that case, I'd
like to still be able to run my tests from a Slim buffer.

#+BEGIN_SRC emacs-lisp
  (add-hook 'slim-mode-hook 'rspec-mode)
#+END_SRC

** =web-mode=

If I'm in =web-mode=, I'd like to:

- Color color-related words with =rainbow-mode=.
- Still be able to run RSpec tests from =web-mode= buffers.
- Indent everything with 2 spaces.

#+BEGIN_SRC emacs-lisp
  (add-hook 'web-mode-hook
            (lambda ()
              (rainbow-mode)
              (rspec-mode)
              (setq web-mode-markup-indent-offset 2)))
#+END_SRC

Use =web-mode= with embedded Ruby files, regular HTML, and PHP.

#+BEGIN_SRC emacs-lisp
  (MattLu/add-auto-mode
   'web-mode
   "\\.erb$"
   "\\.html$"
   "\\.php$"
   "\\.rhtml$")
#+END_SRC

** COMMENT YAML

If I'm editing YAML I'm usually in a Rails project. I'd like to be able to run
the tests from any buffer.

#+BEGIN_SRC emacs-lisp
  (add-hook 'yaml-mode-hook 'rspec-mode)
#+END_SRC

* Terminal

I use =multi-term= to manage my shell sessions. It's bound to =C-c t=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c t") 'multi-term)
#+END_SRC

Use a login shell:

#+BEGIN_SRC emacs-lisp
  (setq multi-term-program-switches "--login")
#+END_SRC

** COMMENT Evil mode
 I'd rather not use Evil in the terminal. It's not especially useful (I don't use
 vi bindings in xterm) and it shadows useful keybindings (=C-d= for EOF, for
 example).

 #+BEGIN_SRC emacs-lisp
   (evil-set-initial-state 'term-mode 'emacs)
 #+END_SRC

** Go on
 I add a bunch of hooks to =term-mode=:

 - I'd like links (URLs, etc) to be clickable.
 - Yanking in =term-mode= doesn't quite work. The text from the paste appears in
   the buffer but isn't sent to the shell process. This correctly binds =C-y= and
   middle-click to yank the way we'd expect.
 - I bind =M-o= to quickly change windows. I'd like that in terminals, too.
 - I don't want to perform =yasnippet= expansion when tab-completing.

 #+BEGIN_SRC emacs-lisp
   (defun MattLu/term-paste (&optional string)
     (interactive)
     (process-send-string
			(get-buffer-process (current-buffer))
			(if string string (current-kill 0))))

   (add-hook 'term-mode-hook
             (lambda ()
               (goto-address-mode)
               (define-key term-raw-map (kbd "C-y") 'MattLu/term-paste)
               (define-key term-raw-map (kbd "<mouse-2>") 'MattLu/term-paste)
               (define-key term-raw-map (kbd "M-o") 'other-window)
               (setq yas-dont-activate t)))
 #+END_SRC

* Publishing and task management with Org-mode

** Display preferences

I like to see an outline of pretty bullets instead of a list of asterisks.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
            (lambda ()
              (org-bullets-mode t)))
#+END_SRC

I like seeing a little downward-pointing arrow instead of the usual ellipsis
(=...=) that org displays when there's stuff under a header.

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "⤵")
#+END_SRC

Use syntax highlighting in source blocks while editing.

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

Make TAB act as if it were issued in a buffer of the language's major mode.

#+BEGIN_SRC emacs-lisp
  (setq org-src-tab-acts-natively t)
#+END_SRC

When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC

Quickly insert a block of elisp:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC

Enable spell-checking in Org-mode.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'flyspell-mode)
#+END_SRC

** Task and org-capture management

Store my org files in =~/org=, maintain an inbox in Dropbox, define the location
of an index file (my main todo list), and archive finished tasks in
=~/org/archive.org=.

#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/documents/org")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

    ;(setq org-inbox-file "~/Dropbox/inbox.org") We can not access to Dropbox
  (setq org-index-file (org-file-path "index.org"))
  (setq org-gtd-file (org-file-path "gtd.org"))
  (setq org-notes-file (org-file-path "notes.org"))
  (setq org-archive-location
        (concat (org-file-path "archive.org") "::* From %s"))
  (setq org-default-notes-file (org-file-path "gtd.org"))
#+END_SRC


*** COMMENT Something we needn't yet
I use [[http://agiletortoise.com/drafts/][Drafts]] to create new tasks, format them according to a template, and
append them to an "inbox.org" file in my Dropbox. This function lets me import
them easily from that inbox file to my index.

#+BEGIN_SRC emacs-lisp
  (defun MattLu/copy-tasks-from-inbox ()
    (when (file-exists-p org-inbox-file)
      (save-excursion
        (find-file org-index-file)
        (goto-char (point-max))
        (insert-file-contents org-inbox-file)
        (delete-file org-inbox-file))))
#+END_SRC

*** Move on
I store all my todos in =~/org/index.org=, so I'd like to derive my agenda from
there.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (list org-directory))
#+END_SRC

set org-refile level deep to max 6

#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets '((org-agenda-files . (:maxlevel . 6))))
#+END_SRC


Hitting =C-c C-x C-s= will mark a todo as done and move it to an appropriate
place in the archive.

#+BEGIN_SRC emacs-lisp
  (defun MattLu/mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))

  (define-key org-mode-map (kbd "C-c C-x C-s") 'MattLu/mark-done-and-archive)
#+END_SRC

Record the time that a todo was archived.

#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC

**** TODO Capturing tasks

Define a few common tasks as capture templates. Specifically, I frequently:

- Record ideas for future blog posts in =~/org/blog-ideas.org=,
- Keep a running grocery list in =~/org/groceries.org=, and
- Maintain a todo list in =~/org/index.org=.

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("n" "notes"
           entry
           (file+headline org-notes-file "Quick notes")
           "* %?\n %i\n %U"
           :empty-lines 1)

          ("g" "Groceries"
           checkitem
           (file (org-file-path "groceries.org")))

          ("v" "Vocabulary"
           table-line
           (file+headline (org-file-path "vocabulary.org") "Vocabulary")
           "| %^{English} | %^{Chinese} | %u|")

          ("l" "letters"
           entry
           (file+headline (org-file-path "vocabulary.org") "Letters")
           "* %?\n %i\n %U")

          ("l" "links"
           entry
           (file+headline org-notes-file "Quick notes")
           "* TODO [#C] %?\n  %i\n %a \n %U"
           :empty-lines 1)

          ("s" "Code Snippet"
           entry
           (file (org-file-path "snippet.org"))
           "* %?\t%^g\n#+BEGIN_SRC %^{language}\n\n#+END_SRC")

          ("w" "work"
           entry
           (file+headline org-gtd-file  "Racobit")
           "* TODO [#A] %?\n  %i\n %U"
           :empty-lines 1)

          ("t" "Todo"
           entry
           (file+headline org-gtd-files "Workspace")
           "* TODO [#B] %?\n %i\n"
           :empty-lines 1)))
#+END_SRC


**** Agenda review

     list stuck projects
#+BEGIN_SRC emacs-lisp
      (setq org-stuck-projects
            '("TODO={.+}/-DONE" nil nil "SCHEDULED:\\|DEADLINE:"))
#+END_SRC

using priority to organize my life
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-custom-commands
        '(("w" . "任务安排")
          ("wa" "重要且紧急的任务" tags-todo "+PRIORITY=\"A\"")
          ("wb" "重要且不紧急的任务" tags-todo "-Weekly-Monthly-Daily+PRIORITY=\"B\"")
          ("wc" "不重要且紧急的任务" tags-todo "+PRIORITY=\"C\"")
          ("p" . "项目安排")
          ("pw" tags-todo "PROJECT+WORK+CATEGORY=\"Racobit\"")
          ("pl" tags-todo "PROJECT+DREAM+CATEGORY=\"MattLu\"")
          ("W" "Weekly Review"
           ((stuck "") ;; review stuck projects as designated by org-stuck-projects
            (tags-todo "PROJECT") ;; review all projects (assuming you use todo keywords to designate projects)
            ))))
 #+END_SRC

**** Keybindings

Bind a few handy keys.

#+BEGIN_SRC emacs-lisp
  (define-key global-map "\C-cl" 'org-store-link)
  (define-key global-map "\C-ca" 'org-agenda)
  (define-key global-map "\C-cc" 'org-capture)
#+END_SRC


Hit =C-c g= to quickly open up my todo list.

#+BEGIN_SRC emacs-lisp
  (defun open-gtd-file ()
    "Open the master org TODO list."
    (interactive)
   ;; (MattLu/copy-tasks-from-inbox)
    (find-file org-gtd-file)
    (flycheck-mode -1)
    (end-of-buffer))

  (global-set-key (kbd "C-c g") 'open-gtd-file)
#+END_SRC


Hit =M-n= to quickly open up a capture template for a new todo.

#+BEGIN_SRC emacs-lisp
  (defun org-capture-todo ()
    (interactive)
    (org-capture :keys "t"))

  (global-set-key (kbd "M-n") 'org-capture-todo)
  (add-hook 'gfm-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
  (add-hook 'haskell-mode-hook
            (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
#+END_SRC

** Exporting

Allow export to markdown and beamer (for presentations).

#+BEGIN_SRC emacs-lisp
  (require 'ox-md)
  (require 'ox-beamer)
#+END_SRC

Allow =babel= to evaluate Emacs lisp, Ruby, dot, or Gnuplot code.

#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (ruby . t)
     (dot . t)
     (gnuplot . t)))
#+END_SRC

Don't ask before evaluating code blocks.

#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

Associate the "dot" language with the =graphviz-dot= major mode.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
#+END_SRC

Translate regular ol' straight quotes to typographically-correct curly quotes
when exporting.

#+BEGIN_SRC emacs-lisp
  (setq org-export-with-smart-quotes t)
#+END_SRC

**** Exporting to HTML

Don't include a footer with my contact and publishing information at the bottom
of every exported HTML document.

#+BEGIN_SRC emacs-lisp
  (setq org-html-postamble nil)
#+END_SRC

Exporting to HTML and opening the results triggers =/usr/bin/sensible-browser=,
which checks the =$BROWSER= environment variable to choose the right browser.
I'd like to always use Firefox, so:

#+BEGIN_SRC emacs-lisp
  (setenv "BROWSER" "safari")
#+END_SRC

**** Exporting to PDF

I want to produce PDFs with syntax highlighting in the code. The best way to do
that seems to be with the =minted= package, but that package shells out to
=pygments= to do the actual work. =pdflatex= usually disallows shell commands;
this enables that.

#+BEGIN_SRC emacs-lisp
  (setq org-latex-pdf-process
        '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

Include the =minted= package in all of my LaTeX exports.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-latex-listings 'minted)
#+END_SRC

**** COMMENT Exporting projects

I have a few Org project definitions that I maintain in a separate elisp file.

#+BEGIN_SRC emacs-lisp
  (load-file ".emacs.d/projects.el")
#+END_SRC

** TODO TeX configuration

I rarely write LaTeX directly any more, but I often export through it with
org-mode, so I'm keeping them together.

Automatically parse the file after loading it.

#+BEGIN_SRC emacs-lisp
  (setq TeX-parse-self t)
#+END_SRC

Always use =pdflatex= when compiling LaTeX documents. I don't really have any
use for DVIs.

#+BEGIN_SRC emacs-lisp
  (setq TeX-PDF-mode t)
#+END_SRC

Open compiled PDFs in =evince= instead of in the editor.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
        '(lambda ()
           (delete '("\\.pdf\\'" . default) org-file-apps)
           (add-to-list 'org-file-apps '("\\.pdf\\'" . "evince %s"))))
#+END_SRC

Enable a minor mode for dealing with math (it adds a few useful keybindings),
and always treat the current file as the "main" file. That's intentional, since
I'm usually actually in an org document.

#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (LaTeX-math-mode)
              (setq TeX-master t)))
#+END_SRC

** COMMENT Add links to Instapaper

I sometimes use [[https://instapaper.com][Instapaper]] to store articles I want to read later. The
=instapaper.el= library sends my URLs there.

#+BEGIN_SRC emacs-lisp
  (require 'instapaper)

  (setq instapaper-username (netrc-username "instapaper.com")
        instapaper-password (netrc-password "instapaper.com"))
#+END_SRC

* COMMENT Blogging

I maintain a blog written in Jekyll. There are plenty of command-line tools to
automate creating a new post, but staying in my editor minimizes friction and
encourages me to write.

This defines a =MattLu/new-blog-post= function, which prompts the user for a title
and creates a new post (with a timestamped and slugged file name) in the blog's
=_posts/= directory. The new post includes appropriate YAML header information.

#+BEGIN_SRC emacs-lisp
  (defvar MattLu/jekyll-posts-directory "~/documents/blog/_posts/")
  (defvar MattLu/jekyll-post-extension ".md")

  (defun MattLu/replace-unusual-characters (title)
    "Replace characters that aren't alphanumeric with hyphens."
    (replace-regexp-in-string " " "-"
                              (downcase (replace-regexp-in-string "[^A-Za-z0-9 ]" " " title))))

  (defun MattLu/slug-for (title)
    "Given a blog post title, return a convenient URL slug.
    Downcase letters and remove special characters."
    (let ((slug (MattLu/replace-unusual-characters title)))
      (while (string-match "--" slug)
        (setq slug (replace-regexp-in-string "--" "-" slug)))
      slug))

  (defun MattLu/timestamped-slug-for (title)
    "Turn a string into a slug with a timestamp and title."
    (concat (format-time-string "%Y-%m-%d")
            "-"
            (MattLu/slug-for title)))

  (defun MattLu/jekyll-yaml-template (title)
    "Return the YAML header information appropriate for a blog
    post. Include the title, the current date, the post layout, and
    an empty list of tags."
    (concat
     "---\n"
     "title: " title "\n"
     "date: " (format-time-string "%Y-%m-%d") "\n"
     "layout: post\n"
     "tags: []\n"
     "---\n\n"))

  (defun MattLu/new-blog-post (title)
    "Create a new blog post in Jekyll."
    (interactive "sPost title: ")
    (let ((post (concat MattLu/jekyll-posts-directory
                        (MattLu/timestamped-slug-for title)
                        MattLu/jekyll-post-extension)))
      (if (file-exists-p post)
          (find-file post)
        (find-file post)
        (insert (MattLu/jekyll-yaml-template title)))))
#+END_SRC

* TODO COMMENT Daily checklist

There are certain things I want to do regularly. I store those in a checklist.
Because different things happen on different days, the checklist is an Org
document generated by a Ruby script.

Running =MattLu/today= either opens today's existing checklist (if it exists), or
renders today's new checklist, copies it into an Org file in =/tmp=, and opens
it.

#+BEGIN_SRC emacs-lisp
  (setq MattLu/checklist-script "~/bin/daily-checklist")

  (defun MattLu/today-checklist-filename ()
    "The filename of today's checklist."
    (concat "/tmp/daily-checklist-" (format-time-string "%Y-%m-%d") ".org"))

  (defun MattLu/today ()
    "Take a look at today's checklist."
    (interactive)
    (let ((filename (MattLu/today-checklist-filename)))
      (if (file-exists-p filename)
          (find-file filename)
        (progn
          (shell-command (concat MattLu/checklist-script " > " filename))
          (find-file filename)))))

  (global-set-key (kbd "C-c t") 'MattLu/today)
#+END_SRC

Open the checklist and my TODO list side-by-side:

#+BEGIN_SRC emacs-lisp
  (defun MattLu/dashboard ()
    (interactive)
    (delete-other-windows)
    (MattLu/today)
    (split-window-right)
    (open-index-file))

  (global-set-key (kbd "C-c d") 'MattLu/dashboard)
#+END_SRC

* COMMENT Email with =mu4e=

Use the =evil= bindings for navigation. They're very similar to the =mutt=
bindings, which matches my muscle memory nicely. =)

#+BEGIN_SRC emacs-lisp
  (require 'evil-mu4e)
#+END_SRC

** Where's my mail? Who am I?

I keep my mail in =~/.mail=. The default maildir would be =~/Maildir=, but I'd
rather hide it; I don't poke around in there manually very often.

This setting matches the paths in my =mbsync= configuration.

#+BEGIN_SRC emacs-lisp
  (setq mu4e-maildir "~/.mail")
#+END_SRC

I only have one context at the moment. If I had another email account, though,
I'd define it in here with an additional =make-mu4e-context= block.

My full name is defined earlier in this configuration file.

#+BEGIN_SRC emacs-lisp
  (setq mu4e-contexts
        `(,(make-mu4e-context
            :name "personal"
            :match-func (lambda (msg)
                          (when msg
                            (string-prefix-p "/personal" (mu4e-message-field msg :maildir))))
            :vars '((user-mail-address . "hello@harryrschwartz.com")
                    (mu4e-trash-folder . "/personal/archive")
                    (mu4e-refile-folder . "/personal/archive")
                    (mu4e-sent-folder . "/personal/sent")
                    (mu4e-drafts-folder . "/personal/drafts")))))
#+END_SRC

** Fetching new mail

I fetch my email with =mbsync=. I've also bound "o" to fetch new mail.

#+BEGIN_SRC emacs-lisp
  (setq mu4e-get-mail-command "killall mbsync; mbsync inboxes")

  (define-key mu4e-headers-mode-map (kbd "o") 'mu4e-update-mail-and-index)
#+END_SRC

Rename files when moving them between directories. =mbsync= supposedly prefers
this; I'm cargo-culting.

#+BEGIN_SRC emacs-lisp
  (setq mu4e-change-filenames-when-moving t)
#+END_SRC

Poll the server for new mail every 5 minutes.

#+BEGIN_SRC emacs-lisp
  (setq mu4e-update-interval 300)
#+END_SRC

** Viewing mail

I check my email pretty often! Probably more than I should. This binds =C-c m=
to close any other windows and open my personal inbox.

In practice, I keep an =*mu4e-headers*= buffer in its own frame, full-screen, on
a dedicated =i3= workspace.

#+BEGIN_SRC emacs-lisp
  (defun MattLu/visit-inbox ()
    (interactive)
    (delete-other-windows)
    (mu4e~headers-jump-to-maildir "/personal/inbox"))

  (global-set-key (kbd "C-c m") 'MattLu/visit-inbox)
#+END_SRC

Open my inbox and sent messages folders with =J-i= and =J-s=, respectively.
These are the only two folders I visit regularly enough to warrant shortcuts.

#+BEGIN_SRC emacs-lisp
  (setq mu4e-maildir-shortcuts '(("/personal/inbox" . ?i)
                                 ("/personal/sent" . ?s)))
#+END_SRC

=mu4e= starts approximately instantaneously, so I don't know why I'd want to
reconsider quitting it.

#+BEGIN_SRC emacs-lisp
  (setq mu4e-confirm-quit nil)
#+END_SRC

** Composing a new message

When I'm composing a new email, default to using the first context.

#+BEGIN_SRC emacs-lisp
  (setq mu4e-compose-context-policy 'pick-first)
#+END_SRC

Compose new messages (as with =C-x m=) using =mu4e-user-agent=.

#+BEGIN_SRC emacs-lisp
  (setq mail-user-agent 'mu4e-user-agent)
#+END_SRC

Enable Org-style tables and list manipulation.

#+BEGIN_SRC emacs-lisp
  (add-hook 'message-mode-hook 'turn-on-orgtbl)
  (add-hook 'message-mode-hook 'turn-on-orgstruct++)
#+END_SRC

Check my spelling while I'm writing.

#+BEGIN_SRC emacs-lisp
  (add-hook 'mu4e-compose-mode-hook 'flyspell-mode)
#+END_SRC

Once I've sent an email, kill the associated buffer instead of just burying it.

#+BEGIN_SRC emacs-lisp
  (setq message-kill-buffer-on-exit t)
#+END_SRC

** Reading an email

Display the sender's email address along with their name.

#+BEGIN_SRC emacs-lisp
  (setq mu4e-view-show-addresses t)
#+END_SRC

Save attachments in my =~/downloads= directory, not my home directory.

#+BEGIN_SRC emacs-lisp
  (setq mu4e-attachment-dir "~/downloads")
#+END_SRC

Hit =C-c C-o= to open a URL in the browser.

#+BEGIN_SRC emacs-lisp
  (define-key mu4e-view-mode-map (kbd "C-c C-o") 'mu4e~view-browse-url-from-binding)
#+END_SRC

While HTML emails are undeniably sinful, we often have to read them. That's
sometimes best done in a browser. This effectively binds =a h= to open the
current email in my default Web browser.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'mu4e-view-actions '("html in browser" . mu4e-action-view-in-browser) t)
#+END_SRC

** Encryption

If a message is encrypted, my reply should always be encrypted, too.

#+BEGIN_SRC emacs-lisp
  (defun MattLu/encrypt-responses ()
    (let ((msg mu4e-compose-parent-message))
      (when msg
        (when (member 'encrypted (mu4e-message-field msg :flags))
          (mml-secure-message-encrypt-pgpmime)))))

  (add-hook 'mu4e-compose-mode-hook 'MattLu/encrypt-responses)
#+END_SRC

** Sending mail over SMTP

I send my email through =msmtp=. It's very fast, and I've already got it
configured from using =mutt=. These settings describe how to send a message:

- Use a sendmail program instead of sending directly from Emacs,
- Tell =msmtp= to infer the correct account from the =From:= address,
- Don't add a "=-f username=" flag to the =msmtp= command, and
- Use =/usr/bin/msmtp=!

#+BEGIN_SRC emacs-lisp
  (setq message-send-mail-function 'message-send-mail-with-sendmail)
  (setq message-sendmail-extra-arguments '("--read-envelope-from"))
  (setq message-sendmail-f-is-evil 't)
  (setq sendmail-program "msmtp")
#+END_SRC

** Org integration

=org-mu4e= lets me store links to emails. I use this to reference emails in my
TODO list while keeping my inbox empty.

#+BEGIN_SRC emacs-lisp
  (require 'org-mu4e)
#+END_SRC

When storing a link to a message in the headers view, link to the message
instead of the search that resulted in that view.

#+BEGIN_SRC emacs-lisp
  (setq org-mu4e-link-query-in-headers-mode nil)
#+END_SRC

** Configure BBDB with mu4e

Use BBDB to handle my address book.

#+BEGIN_SRC emacs-lisp
  (require 'bbdb-mu4e)
#+END_SRC

Don't try to do address completion with mu4e. Use BBDB instead:

#+BEGIN_SRC emacs-lisp
  (setq mu4e-compose-complete-addresses nil)
#+END_SRC

* Writing prose

  ** Look up definitions in Webster 1913

I look up definitions by hitting =C-x w=, which shells out to =sdcv=. I've
loaded that with the (beautifully lyrical) 1913 edition of Webster's dictionary,
so these definitions are a lot of fun.

#+BEGIN_SRC emacs-lisp
  (defun MattLu/dictionary-prompt ()
    (read-string
     (format "Word (%s): " (or (MattLu/region-or-word) ""))
     nil
     nil
     (MattLu/region-or-word)))

  (defun MattLu/dictionary-define-word ()
    (interactive)
    (let* ((word (MattLu/dictionary-prompt))
           (buffer-name (concat "Definition: " word)))
      (with-output-to-temp-buffer buffer-name
        (shell-command (format "sdcv -n %s" word) buffer-name))))

  (define-key global-map (kbd "C-x w") 'MattLu/dictionary-define-word)
#+END_SRC

** Look up words in a thesaurus

Synosaurus is hooked up to wordnet to provide access to a thesaurus. Hitting
=C-c s= summons it.

#+BEGIN_SRC emacs-lisp
  (setq-default synosaurus-backend 'synosaurus-backend-wordnet)
  (add-hook 'after-init-hook #'synosaurus-mode)
#+END_SRC

** Configure =abbrev-mode=

My email address is too long, so I like to keep some personal information as
abbreviations.

I'm prefixing them with =@= to avoid collisions with real words.

#+BEGIN_SRC emacs-lisp
  (define-abbrev-table 'global-abbrev-table
    '(("@name" "Harry R. Schwartz")
      ("@email" "hello@harryrschwartz.com")
      ("@site" "http://harryrschwartz.com")))
#+END_SRC

Always enable =abbrev-mode=:

#+BEGIN_SRC emacs-lisp
  (setq-default abbrev-mode t)
#+END_SRC

** Editing with Markdown

Because I can't always use =org=.

I'd like spell-checking running when editing Markdown.

#+BEGIN_SRC emacs-lisp
  (add-hook 'gfm-mode-hook 'flyspell-mode)
#+END_SRC

Associate =.md= files with GitHub-flavored Markdown.

#+BEGIN_SRC emacs-lisp
  (MattLu/add-auto-mode 'gfm-mode "\\.md$")
#+END_SRC

Use =pandoc= to render the results.

#+BEGIN_SRC emacs-lisp
  (setq markdown-command "pandoc --standalone --mathjax --from=markdown")
#+END_SRC

** Wrap paragraphs automatically

=AutoFillMode= automatically wraps paragraphs, kinda like hitting =M-q=. I wrap
a lot of paragraphs, so this automatically wraps 'em when I'm writing text,
Markdown, or Org.

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'gfm-mode-hook 'turn-on-auto-fill)
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
#+END_SRC

Sometimes, though, I don't wanna wrap text. This toggles wrapping with =C-c q=:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c q") 'auto-fill-mode)
#+END_SRC

** Linting prose

I use [[http://proselint.com/][proselint]] to check my prose for common errors. This creates a flycheck
checker that runs proselint in texty buffers and displays my errors.

#+BEGIN_SRC emacs-lisp
  (require 'flycheck)

  (flycheck-define-checker proselint
    "A linter for prose."
    :command ("proselint" source-inplace)
    :error-patterns
    ((warning line-start (file-name) ":" line ":" column ": "
              (id (one-or-more (not (any " "))))
              (message (one-or-more not-newline)
                       (zero-or-more "\n" (any " ") (one-or-more not-newline)))
              line-end))
    :modes (text-mode markdown-mode gfm-mode org-mode))

  (add-to-list 'flycheck-checkers 'proselint)
#+END_SRC

Use flycheck in the appropriate buffers:

#+BEGIN_SRC emacs-lisp
  (add-hook 'markdown-mode-hook #'flycheck-mode)
  (add-hook 'gfm-mode-hook #'flycheck-mode)
  (add-hook 'text-mode-hook #'flycheck-mode)
  (add-hook 'org-mode-hook #'flycheck-mode)
#+END_SRC

** Enable region case modification

#+BEGIN_SRC emacs-lisp
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+END_SRC

* Writing thesis

 Write raw LaTex document using [[https://www.gnu.org/software/auctex/][auctex]]

#+BEGIN_SRC emacs-lisp
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq-default TeX-master nil)
#+END_SRC

** Set some usefull commands of latex

 #+BEGIN_SRC emacs-lisp
   (eval-after-load "tex"
     '(setq TeX-command-list
                   '(("XeLaTeX_SyncteX" "%`xelatex --synctex=1%(mode)%' %t" TeX-run-TeX nil
                      (latex-mode doctex-mode)
                      :help "Run XeLaTeX")
                     ("TeX" "%(PDF)%(tex) %`%S%(PDFout)%(mode)%' %t" TeX-run-TeX nil
                      (plain-tex-mode texinfo-mode ams-tex-mode)
                      :help "Run plain TeX")
                     ("LaTeX" "%`%l%(mode)%' %t" TeX-run-TeX nil
                      (latex-mode doctex-mode)
                      :help "Run LaTeX")
                     ("Makeinfo" "makeinfo %t" TeX-run-compile nil
                      (texinfo-mode)
                      :help "Run Makeinfo with Info output")
                     ("Makeinfo HTML" "makeinfo --html %t" TeX-run-compile nil
                      (texinfo-mode)
                      :help "Run Makeinfo with HTML output")
                     ("AmSTeX" "%(PDF)amstex %`%S%(PDFout)%(mode)%' %t" TeX-run-TeX nil
                      (ams-tex-mode)
                      :help "Run AMSTeX")
                     ("ConTeXt" "texexec --once --texutil %(execopts)%t" TeX-run-TeX nil
                      (context-mode)
                      :help "Run ConTeXt once")
                     ("ConTeXt Full" "texexec %(execopts)%t" TeX-run-TeX nil
                      (context-mode)
                      :help "Run ConTeXt until completion")
                     ("BibTeX" "bibtex %s" TeX-run-BibTeX nil t
                      :help "Run BibTeX")
                     ("View" "%V" TeX-run-discard-or-function nil t
                      :help "Run Viewer")
                     ("Print" "%p" TeX-run-command t t
                      :help "Print the file")
                     ("Queue" "%q" TeX-run-background nil t
                      :help "View the printer queue" :visible TeX-queue-command)
                     ("File" "%(o?)dvips %d -o %f " TeX-run-command t t
                      :help "Generate PostScript file")
                     ("Index" "makeindex %s" TeX-run-command nil t
                      :help "Create index file")
                     ("Check" "lacheck %s" TeX-run-compile nil
                      (latex-mode)
                      :help "Check LaTeX file for correctness")
                     ("Spell" "(TeX-ispell-document \"\")" TeX-run-function nil t
                      :help "Spell-check the document")
                     ("Clean" "TeX-clean" TeX-run-function nil t
                      :help "Delete generated intermediate files")
                     ("Clean All" "(TeX-clean t)" TeX-run-function nil t
                      :help "Delete generated intermediate and output files")
                     ("Other" "" TeX-run-command t t
                      :help "Run an arbitrary command")
                     ("Jump to PDF" "%V" TeX-run-discard-or-function nil t
                      :help "Run Viewer")
                     ("TeXcount" "texcount %s.tex" TeX-run-compile nil t
                      :help "Run texcount")
                     ) ))
 #+END_SRC

** Enable forward and inverse search

 #+BEGIN_SRC emacs-lisp
  (setq TeX-source-correlate-method (quote synctex))
  (setq TeX-source-correlate-mode t)
  (setq TeX-source-correlate-start-server t)
 #+END_SRC

** Set pdf viewer

 #+BEGIN_SRC emacs-lisp
   (setq TeX-view-program-selection  '((output-pdf "PDF Viewer")))
   (setq TeX-view-program-list
         '(("PDF Viewer" "/Applications/Skim.app/Contents/SharedSupport/displayline -b -g %n %o %b")))
 #+END_SRC

** Using company-auctex as backend

 #+BEGIN_SRC emacs-lisp
   (require 'company-auctex)
   (company-auctex-init)
 #+END_SRC

** Set [[https://www.gnu.org/software/auctex/reftex.html][reftex]]  References, labels, citations

 #+BEGIN_SRC emacs-lisp
   (add-hook 'LaTeX-mode-hook 'turn-on-reftex) ; with Auctex Latex mode
   (add-hook 'latex-mode-hook 'turn-on-reftex) ; with Emacs latex mode
   (setq reftex-plug-into-AUCTeX t)
 #+END_SRC

* =dired=

Load up the assorted =dired= extensions.

#+BEGIN_SRC emacs-lisp
  (require 'dired-x)
  (require 'dired+)
  (require 'dired-open)
#+END_SRC

Open media with the appropriate programs.

#+BEGIN_SRC emacs-lisp
  (setq dired-open-extensions
        '(("pdf" . "preivew")
          ("mkv" . "mpv")
          ("mp4" . "mpv")
          ("avi" . "mpv")))
#+END_SRC

These are the switches that get passed to =ls= when =dired= gets a list of
files. We're using:

- =l=: Use the long listing format.
- =h=: Use human-readable sizes.
- =v=: Sort numbers naturally.
- =A=: Almost all. Doesn't include "=.=" or "=..=".

#+BEGIN_SRC emacs-lisp
  (setq-default dired-listing-switches "-lhvA")
#+END_SRC

Use "j" and "k" to move around in =dired=.

#+BEGIN_SRC emacs-lisp
;  (evil-define-key 'normal dired-mode-map (kbd "j") 'dired-next-line)
;  (evil-define-key 'normal dired-mode-map (kbd "k") 'dired-previous-line)
#+END_SRC

Kill buffers of files/directories that are deleted in =dired=.

#+BEGIN_SRC emacs-lisp
  (setq dired-clean-up-buffers-too t)
#+END_SRC

Always copy directories recursively instead of asking every time.

#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-copies 'always)
#+END_SRC

Ask before recursively /deleting/ a directory, though.

#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-deletes 'top)
#+END_SRC

Open a file with an external program (that is, through =xdg-open=) by hitting
=C-c C-o=.

#+BEGIN_SRC emacs-lisp
  (defun dired-xdg-open ()
    "In dired, open the file named on this line."
    (interactive)
    (let* ((file (dired-get-filename nil t)))
      (call-process "xdg-open" nil 0 nil file)))

  (define-key dired-mode-map (kbd "C-c C-o") 'dired-xdg-open)
#+END_SRC

* Editing settings

** Quickly visit Emacs
configuration

I futz around with my dotfiles a lot. This binds =C-c e= to quickly open my
Emacs configuration file.

#+BEGIN_SRC emacs-lisp
  (defun MattLu/visit-emacs-config ()
    (interactive)
    (find-file "~/.emacs.d/configuration.org"))

  (global-set-key (kbd "C-c e") 'MattLu/visit-emacs-config)
#+END_SRC

** Always kill current buffer

Assume that I always want to kill the current buffer when hitting =C-x k=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x k") 'MattLu/kill-current-buffer)
#+END_SRC

** Look for executables in =/usr/local/bin=.

Add system path to emacs.

#+BEGIN_SRC emacs-lisp
  (MattLu/append-to-path "/usr/local/bin")
	(MattLu/append-to-path "/Library/TeX/texbin")
#+END_SRC

** Use =company-mode= everywhere

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook 'global-company-mode)
  (setq company-tooltip-limit 10)                      ; bigger popup window
  (setq company-idle-delay .3)                         ; decrease delay before autocompletion popup shows
  (setq company-echo-delay 0)                          ; remove annoying blinking
  (setq company-transformers '(company-sort-by-occurrence)) ; weight by frequency
#+END_SRC

Set TAB for complete cycle

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'company
    '(progn
       (define-key company-active-map (kbd "TAB") 'company-complete-common-or-cycle)
       (define-key company-active-map (kbd "<tab>") 'company-complete-common-or-cycle)))
#+END_SRC

** Always indent with spaces

Never use tabs. Tabs are the devil’s whitespace.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

** TODO Configure yasnippet

I keep my snippets in =~/.emacs/snippets/text-mode=, and I always want =yasnippet=
enabled.

#+BEGIN_SRC emacs-lisp
  (setq yas-snippet-dirs '("~/.emacs.d/snippets/text-mode"))
  (yas-global-mode 1)
#+END_SRC

I /don’t/ want =ido= to automatically indent the snippets it inserts. Sometimes
this looks pretty bad (when indenting org-mode, for example, or trying to guess
at the correct indentation for Python).

#+BEGIN_SRC emacs-lisp
  (setq yas/indent-line nil)
#+END_SRC

** Configure =ido=

#+BEGIN_SRC emacs-lisp
  (setq ido-enable-flex-matching t)
  (setq ido-everywhere t)
  (ido-mode 1)
  (ido-ubiquitous-mode 1)
  (flx-ido-mode 1) ; better/faster matching
  (setq ido-create-new-buffer 'always) ; don't confirm to create new buffers
  (ido-vertical-mode 1)
  (setq ido-vertical-define-keys 'C-n-and-C-p-only)
#+END_SRC

** Use =smex= to handle =M-x= with =ido=

#+BEGIN_SRC emacs-lisp
  (smex-initialize)

  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)
#+END_SRC

** Switch and rebalance windows when splitting

When splitting a window, I invariably want to switch to the new window. This
makes that automatic.

#+BEGIN_SRC emacs-lisp
  (defun MattLu/split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun MattLu/split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))

  (global-set-key (kbd "C-x 2") 'MattLu/split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'MattLu/split-window-right-and-switch)
#+END_SRC

** Mass editing of =grep= results

I like the idea of mass editing =grep= results the same way I can edit filenames
in =dired=. These keybindings allow me to use =C-x C-q= to start editing =grep=
results and =C-c C-c= to stop, just like in =dired=.

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'grep
    '(define-key grep-mode-map
      (kbd "C-x C-q") 'wgrep-change-to-wgrep-mode))

  (eval-after-load 'wgrep
    '(define-key grep-mode-map
      (kbd "C-c C-c") 'wgrep-finish-edit))

  (setq wgrep-auto-save-buffer t)
#+END_SRC

** Configure =wrap-region=

#+BEGIN_SRC emacs-lisp
  (wrap-region-global-mode t)
  (wrap-region-add-wrapper "/" "/" nil 'ruby-mode)
  (wrap-region-add-wrapper "`" "`" nil '(markdown-mode ruby-mode))
#+END_SRC

** Split horizontally for temporary buffers

Horizonal splits are nicer for me, since I usually use a wide monitor. This is
handy for handling temporary buffers (like compilation or test output).

#+BEGIN_SRC emacs-lisp
  (defun MattLu/split-horizontally-for-temp-buffers ()
    (when (one-window-p t)
      (split-window-horizontally)))

  (add-hook 'temp-buffer-window-setup-hook
            'MattLu/split-horizontally-for-temp-buffers)
#+END_SRC

** Use projectile everywhere

#+BEGIN_SRC emacs-lisp
  (projectile-global-mode)
#+END_SRC

** Add a bunch of engines for =engine-mode=

Enable [[https://github.com/hrs/engine-mode][engine-mode]] and define a few useful engines.

#+BEGIN_SRC emacs-lisp
  (require 'engine-mode)

  (defengine duckduckgo
    "https://duckduckgo.com/?q=%s"
    :keybinding "d")

  (defengine github
    "https://github.com/search?ref=simplesearch&q=%s"
    :keybinding "g")

  (defengine google
    "https://www.google.com/search?ie=utf-8&oe=utf-8&q=%s")

  (defengine rfcs
    "https://pretty-rfc.herokuapp.com/search?q=%s")

  (defengine stack-overflow
    "https://stackoverflow.com/search?q=%s"
    :keybinding "s")

  (defengine wikipedia
    "https://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
    :keybinding "w")

  (defengine wiktionary
    "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

  (defengine youtube
    "https://www.youtube.com/results?search_query=%s")

  (engine-mode t)
#+END_SRC

** Use multiple cursors



Set multiple cursors for better marker words

#+BEGIN_SRC emacs-lisp
  (require 'multiple-cursors)
  (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
#+END_SRC

** Use expand region

Expand region increases the selected region by semantic units.
Just keep pressing the key until it selects what you want.

#+BEGIN_SRC emacs-lisp
  (require 'expand-region)
  (global-set-key (kbd "C-=") 'er/expand-region)
#+END_SRC
* Set custom keybindings

Just a few handy functions.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-w") 'backward-kill-word)
  (global-set-key (kbd "M-/") 'hippie-expand)
  (global-set-key (kbd "M-o") 'other-window)
#+END_SRC

Remap when working in terminal Emacs.

#+BEGIN_SRC emacs-lisp
  (define-key input-decode-map "\e[1;2A" [S-up])
#+END_SRC
