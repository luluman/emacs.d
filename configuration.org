#+TITLE: Emacs Configuration
#+ORIGNAL:Harry R. Schwartz
#+OPTIONS: toc:nil num:nil
#+STARTUP: overview
* Configure =use-package=

#+BEGIN_SRC emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-verbose t)
  (setq use-package-always-ensure t)
#+END_SRC

use auto-package-update to keep your packages updated automatically

#+BEGIN_SRC emacs-lisp
(use-package auto-package-update
  :config
  (setq auto-package-update-delete-old-versions t)
  (setq auto-package-update-hide-results t)
  (auto-package-update-maybe))
#+END_SRC

Always compile packages, and use the newest version available.

#+BEGIN_SRC emacs-lisp
  (use-package auto-compile
    :config (auto-compile-on-load-mode)
    (setq load-prefer-newer t))
#+END_SRC

use-package supports git repository

#+begin_src emacs-lisp
  (use-package quelpa-use-package
    :disabled t
    :config
    (setq use-package-ensure-function 'quelpa))
#+end_src

#+begin_src emacs-lisp
  (setq comp-deferred-compilation t)
#+end_src

* Use sensible-defaults.el

Use [[https://github.com/hrs/sensible-defaults.el][sensible-defaults.el]] for some basic settings.

#+BEGIN_SRC emacs-lisp
  (load-file "~/.emacs.d/sensible-defaults.el")
  (sensible-defaults/use-all-settings)
  (sensible-defaults/use-all-keybindings)
  (sensible-defaults/backup-to-temp-directory)
#+END_SRC

* Add =resources= to =load-path=

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/resources/")
#+END_SRC

* Utility functions

Define a big ol' bunch of handy utility functions.

#+BEGIN_SRC emacs-lisp
  (defun my/view-buffer-name ()
    "Display the filename of the current buffer."
    (interactive)
    (message (buffer-file-name)))

  (defun my/rename-file (new-name)
    (interactive "FNew name: ")
    (let ((filename (buffer-file-name)))
      (if filename
          (progn
            (when (buffer-modified-p)
               (save-buffer))
            (rename-file filename new-name t)
            (kill-buffer (current-buffer))
            (find-file new-name)
            (message "Renamed '%s' -> '%s'" filename new-name))
        (message "Buffer '%s' isn't backed by a file!" (buffer-name)))))

  (defun my/generate-scratch-buffer ()
    "Create and switch to a temporary scratch buffer with a random
       name."
    (interactive)
    (switch-to-buffer (make-temp-name "scratch-")))

  (defun my/unfill-paragraph ()
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive)
    (let ((fill-column (point-max)))
      (fill-paragraph nil)))

  (defun my/visit-last-dired-file ()
    "Open the last file in an open dired buffer."
    (end-of-buffer)
    (previous-line)
    (dired-find-file))

  (defun my/add-auto-mode (mode &rest patterns)
    "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
    (dolist (pattern patterns)
      (add-to-list 'auto-mode-alist (cons pattern mode))))

  (defun my/find-file-as-sudo ()
    (interactive)
    (let ((file-name (buffer-file-name)))
      (when file-name
        (find-alternate-file (concat "/sudo::" file-name)))))

  (defun my/region-or-word ()
    (if mark-active
        (buffer-substring-no-properties (region-beginning)
                                        (region-end))
      (thing-at-point 'word)))

  (defun my/insert-random-string (len)
    "Insert a random alphanumeric string of length len."
    (interactive)
    (let ((mycharset "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstyvwxyz"))
      (dotimes (i len)
        (insert (elt mycharset (random (length mycharset)))))))

  (defun my/generate-password ()
    "Insert a good alphanumeric password of length 30."
    (interactive)
    (my/insert-random-string 30))

  (defun my/append-to-path (path)
    "Add a path both to the $PATH variable and to Emacs' exec-path."
    (setenv "PATH" (concat (getenv "PATH") ":" path))
    (add-to-list 'exec-path path))
#+END_SRC

proxy settings
#+begin_src emacs-lisp
  ;; https://github.com/happyo/emacs.d/blob/main/lisp/init-proxy.el
  (setq my/socks-proxy "127.0.0.1:7891")    ; SOCKS proxy
  (setq my/remote-host-name "mac")
  (setq my/socks5 nil)

  (defun my/new-socks5-proxy ()
    (apply #'start-process "socks5-proxy"
           (format "*socks5-proxy-%s*" my/remote-host-name)
           "ssh" (list "-ND" my/socks-proxy my/remote-host-name)))

  (defun proxy-socks-show ()
    "Show SOCKS proxy."
    (interactive)
    (if (process-live-p my/socks5)
        (message "Current SOCKS%d proxy is %s:%s"
                 (cadddr socks-server) (cadr socks-server) (caddr socks-server))
      (message "No SOCKS proxy")))

  (defun proxy-socks-enable ()
    "Enable SOCKS proxy."
    (interactive)
    (unless (process-live-p my/socks5)
      (setq my/socks5 (my/new-socks5-proxy)))
    (require 'socks)
    (setq url-gateway-method 'socks
          socks-noproxy '("localhost"))
    (let* ((proxy (split-string my/socks-proxy ":"))
           (host (car proxy))
           (port (string-to-number (cadr proxy))))
      (setq socks-server `("Default server" ,host ,port 5)))
    ;; (setenv "all_proxy" (concat "socks5://" my/socks-proxy))
    (proxy-socks-show))

  (defun proxy-socks-disable ()
    "Disable SOCKS proxy."
    (interactive)
    (when my/socks5
      (kill-process my/socks5)
      (setq my/socks5 nil))
    (setq url-gateway-method 'native
          socks-noproxy nil
          socks-server nil)
    ;; (setenv "all_proxy" "")
    (proxy-socks-show))

  (defun proxy-socks-toggle ()
    "Toggle SOCKS proxy."
    (interactive)
    (if (process-live-p my/socks5)
        (proxy-socks-disable)
      (proxy-socks-enable)))
#+end_src

* UI preferences
** Tweak window chrome

I don't usually use the menu or scroll bar, and they take up useful space.

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (if (display-graphic-p)
      (progn (scroll-bar-mode -1))
    (menu-bar-mode -1))
#+END_SRC

** Use fancy lambdas

Why not?

#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode t)
#+END_SRC

** Load up a theme
*** personal preferences

 better vertical border and region color

#+BEGIN_SRC emacs-lisp
  ;; Set symbol for the border │ or ┃
  (set-display-table-slot standard-display-table
                          'vertical-border
                          (make-glyph-code ?┃))
#+END_SRC

#+begin_src emacs-lisp
  (defun transparency (value)
    "Sets the transparency of the frame window. 0=transparent/100=opaque."
    (interactive "Transparency Value 0 - 100 opaque:")
    (set-frame-parameter (selected-frame) 'alpha value))
#+end_src

*** theme manager

Those themes are what I like most.

#+begin_src emacs-lisp
  (use-package modus-themes
    :no-require t
    :custom
    (modus-themes-italic-constructs t)
    (modus-themes-bold-constructs nil))
  (use-package ef-themes
    :no-require t)
#+end_src

Theme loading symbols.

#+begin_src emacs-lisp
  (defvar theme-pool
    '(modus-operandi
      modus-vivendi
      modus-operandi-tinted
      modus-vivendi-tinted
      modus-operandi-deuteranopia
      modus-vivendi-deuteranopia
      modus-operandi-tritanopia
      modus-vivendi-tritanopia
      ef-light
      ef-dark
      ef-day
      ef-night
      ))

  (defvar my/choosing-theme 'modus-vivendi)
#+end_src

#+begin_src emacs-lisp
  (defun my/load-theme (theme)
    (face-remap-add-relative 'vertical-border '(:inherit default))
    (load-theme theme t)
    (when (cl-search "doom" (symbol-name  theme))
      (set-face-background 'vertical-border "bg")))
#+end_src

#+begin_src emacs-lisp
  (defun my/themes-toggle ()
    "Toggle between themes defined in theme-pool."
    (interactive)
    (let* ((current-theme (car custom-enabled-themes))
           (index (cl-position current-theme theme-pool)))
      (if index
          (setq my/choosing-theme
                (nth (% (+ 1 index) (length theme-pool)) theme-pool))
        (setq my/choosing-theme (car theme-pool)))
      (disable-theme current-theme)
      (my/load-theme my/choosing-theme)
      (message "change theme to `%s'" my/choosing-theme)))
#+end_src

Using light theme on MacOS.

#+BEGIN_SRC emacs-lisp
  (defun my/apply-light-theme ()
    (transparency 98)
    (load-theme 'ef-day t))
#+END_SRC

#+begin_src emacs-lisp
  (if (display-graphic-p)
      (my/apply-light-theme)
    (my/load-theme my/choosing-theme))
#+end_src

#+BEGIN_SRC emacs-lisp
  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame)
                  (with-selected-frame frame
                    (my/load-theme my/choosing-theme)))))

#+END_SRC

Custom face when running in 256-color terminal

#+begin_src emacs-lisp
  (defun my/load-custom-face-el ()
    (if (and (eq my/choosing-theme 'nord)
             (eq 256 (display-color-cells)))
        (load-file "~/.emacs.d/custom-face.el")))

  (if (daemonp)
      (add-hook 'after-make-frame-functions
                (lambda (frame)
                  (with-selected-frame
                      frame (my/load-custom-face-el))))
    (my/load-custom-face-el))
#+end_src

** Mode-Line

#+begin_src emacs-lisp
  (use-package minions
    :custom
    (minions-mode-line-delimiters (cons "" ""))
    (minions-prominent-modes '(flymake-mode))

    :config
    (defun +set-minions-mode-line-lighter ()
      (setq minions-mode-line-lighter
            (if (display-graphic-p) "⚙" "#")))

    (add-hook 'server-after-make-frame-hook #'+set-minions-mode-line-lighter)
    (minions-mode 1))
#+end_src

#+begin_src emacs-lisp
  (use-package time
    :config
    (display-time)
    :custom
    (display-time-default-load-average nil))
#+end_src

#+BEGIN_SRC emacs-lisp
  (size-indication-mode)
  (column-number-mode)
  (setq mode-line-frame-identification " ")
  (setq mode-line-end-spaces "")
#+END_SRC

** COMMENT Scroll conservatively

When point goes outside the window, Emacs usually recenters the buffer point.
I'm not crazy about that. This changes scrolling behavior to only scroll as far
as point goes.

#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC

** Set default font and configure font resizing

I'm partial to Inconsolata.

The standard =text-scale-= functions just resize the text in the current buffer;
I'd generally like to resize the text in /every/ buffer, and I usually want to
change the size of the modeline, too (this is especially helpful when
presenting). These functions and bindings let me resize everything all together!

Note that this overrides the default font-related keybindings from
=sensible-defaults=.

#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'gnu/linux)
      (setq my/default-font "Ubuntu Mono")
    (setq my/default-font "Source Code Pro"))

  (setq my/default-font-size 14)
  (setq my/current-font-size my/default-font-size)

  (setq my/font-change-increment 1.1)

  (defun my/font-code ()
    "Return a string representing the current font (like \"Inconsolata-14\")."
    (concat my/default-font "-" (number-to-string my/current-font-size)))

  (defun my/set-font-size ()
    "Set the font to `my/default-font' at `my/current-font-size'.
        Set that for the current frame, and also make it the default for
        other, future frames."
    (let ((font-code (my/font-code)))
      (add-to-list 'default-frame-alist (cons 'font font-code))
      (set-frame-font font-code)))

  (defun my/reset-font-size ()
    "Change font size back to `my/default-font-size'."
    (interactive)
    (setq my/current-font-size my/default-font-size)
    (my/set-font-size))

  (defun my/increase-font-size ()
    "Increase current font size by a factor of `my/font-change-increment'."
    (interactive)
    (setq my/current-font-size
          (ceiling (* my/current-font-size my/font-change-increment)))
    (my/set-font-size))

  (defun my/decrease-font-size ()
    "Decrease current font size by a factor of `my/font-change-increment', down to a minimum size of 1."
    (interactive)
    (setq my/current-font-size
          (max 1
               (floor (/ my/current-font-size my/font-change-increment))))
    (my/set-font-size))

  (when (member my/default-font
                (font-family-list))
    (my/reset-font-size))
#+END_SRC

** Highlight the current line

=global-hl-line-mode= softly highlights the background color of the line
containing point. It makes it a bit easier to find point, and it's useful when
pairing or presenting code.

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode)
#+END_SRC

** Highlight uncommitted changes

Use the =git-gutter= package to highlight changed-and-uncommitted lines when
programming.

#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :custom
    ;; │┃▕▐
    (git-gutter:window-width 1)
    (git-gutter:update-interval 0.3)
    (git-gutter:always-show-separator t)
    (git-gutter:added-sign "▐")
    (git-gutter:deleted-sign "▐")
    (git-gutter:modified-sign "▐")
    :custom-face
    (git-gutter:added ((t (:foreground "#438340" :background nil))))
    (git-gutter:deleted ((t (:foreground "#815EDD" :background nil))))
    (git-gutter:modified ((t (:foreground "#3471E3" :background nil))))
    ;; :hook
    ;; (git-gutter-mode
    ;; . (lambda ()
    ;;     (git-gutter:set-window-margin (git-gutter:window-margin))))
    :init
    (global-git-gutter-mode t)
    :bind
    ("C-x C-g" . git-gutter))
#+END_SRC

** Display line number

#+BEGIN_SRC emacs-lisp
  (setq-default display-line-numbers-width 4)
  (setq display-line-numbers-grow-only t)
  (add-hook 'text-mode-hook (lambda () (display-line-numbers-mode t)))
  (add-hook 'prog-mode-hook (lambda () (display-line-numbers-mode t)))
  (add-hook 'conf-mode-hook (lambda () (display-line-numbers-mode t)))
#+END_SRC

** COMMENT Using highlight indentation

#+BEGIN_SRC emacs-lisp
  (use-package highlight-indent-guides
    :hook (prog-mode . (lambda ()
                         (unless (derived-mode-p 'json-ts-mode)
                           (highlight-indent-guides-mode))))
    :custom
    (highlight-indent-guides-method 'character)
    (highlight-indent-guides-responsive 'top)
    (highlight-indent-guides-delay 1)
    :config
    (when (= (display-color-cells) 16777216)
      (set-face-background 'highlight-indent-guides-odd-face "darkgray")
      (set-face-background 'highlight-indent-guides-even-face "dimgray")
      (set-face-foreground 'highlight-indent-guides-character-face "dimgray")))
#+END_SRC

** display system Information

#+begin_src emacs-lisp
  (defun symon--display-update-modify (orig-fun &rest args)
    "symon step aside other message"
    (if (current-message)
        (when (string-match-p "\\(MEM:+.*CPU:+.*RX:+.*TX:+.*\\|Quit\\|Reverting\\ buffer\\|Mark\\ set\\)"
                              (current-message))
          (apply orig-fun args))
      (apply orig-fun args)))
#+end_src

#+BEGIN_SRC emacs-lisp
  (use-package symon
    :load-path "~/.emacs.d/symon/"
    :config
    (symon-mode)
    (advice-add 'symon--display-update
                :around 'symon--display-update-modify))
#+END_SRC

* Hydra

#+begin_src emacs-lisp
  (use-package hydra)
#+end_src
* Project management

I use a few packages in virtually every programming or writing environment to
manage the project, handle auto-completion, search for terms, and deal with
version control. That's all in here.

** project-cmake

The package project-cmake incorporates the required logic to understand that a
project is to be configured, built and tested using CMake and CTest.

#+begin_src emacs-lisp
  (use-package project-cmake
    :if (eq system-type 'gnu/linux)
    :load-path "~/.emacs.d/project-cmake/"
    :custom
    (project-vc-merge-submodules nil)
    (project-vc-extra-root-markers '(".dir-locals.el"))
    (project-cmake-build-directory-name "build")
    :config
    (put 'compilation-environment 'safe-local-variable #'listp)
    (put 'project-cmake-configuration-arguments 'safe-local-variable #'listp)
    (put 'project-cmake-build-type 'safe-local-variable #'stringp)
    (put 'project-cmake-kit 'safe-local-variable #'symbolp)
    (put 'project-cmake-generator 'safe-local-variable #'stringp)
    (put 'project-cmake-source-directory-name 'safe-local-variable #'stringp)
    (project-cmake-scan-kits))
#+end_src

** =ripgrep=

Install and configure [[https://github.com/Wilfred/deadgrep][deadgrep]] as an interface to =ripgrep=.

#+begin_src emacs-lisp
  (use-package deadgrep
    :bind
    ("C-c s" . deadgrep)
    ("C-x s" . deadgrep))

  (use-package wgrep-deadgrep)
#+end_src

** find-file-in-project

Find file/directory and review Diff/Patch/Commit quickly everywhere.

#+begin_src emacs-lisp
  (use-package find-file-in-project
    :custom
    (ffip-use-rust-fd t)
    :bind
    ("C-x f" . find-file-in-project)
    :config
    (push "*/.cache" ffip-prune-patterns))
#+end_src

** =dumb-jump=

The =dumb-jump= package works well enough in a [[https://github.com/jacktasia/dumb-jump#supported-languages][ton of environments]], and it
doesn't require any additional setup. bounding as official recommendation.

#+begin_src emacs-lisp
  (use-package dumb-jump
    :commands (dumb-jump-xref-activate)
    :custom
    (dumb-jump-quiet t)
    (dumb-jump-selector 'completing-read)
    (dumb-jump-force-searcher 'rg)
    :init
    (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
#+end_src

** flymake

#+BEGIN_SRC emacs-lisp
  (use-package flymake
    :pin gnu
    :init
    (package-install 'flymake t) ;; install the latest gnu-flymake
    :custom
    (flymake-mode-line-lighter "Φ")
    (flymake-margin-indicator-position 'right-margin)
    (flymake-autoresize-margins t))
#+END_SRC

** =magit=

I use =magit= to handle version control. It's lovely, but I tweak a few things:

- I bring up the status menu with =C-x g=.
- The default behavior of =magit= is to ask before pushing. I haven't had any
  problems with accidentally pushing, so I'd rather not confirm that every time.
- Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes
  beyond 50 characters.
- I'd like to start in the insert state when writing a commit message.

#+begin_src emacs-lisp
  (use-package magit
    :bind
    ("C-x g" . magit-status)
    :config
    (use-package with-editor)
    (setq magit-bind-magit-project-status nil)
    :hook
    (git-commit-mode . (lambda ()
                         "Set up the Git commit message buffer."
                         (setq fill-column 72)))
    :custom
    (magit-push-always-verify nil)
    (git-commit-summary-max-length 50)
    (magit-blame-goto-chunk-hook '(magit-blame-maybe-show-message)))
#+end_src

I'm also partial to =git-timemachine=, which lets you quickly page through the
history of a file.

#+begin_src emacs-lisp
  (use-package git-timemachine)
#+end_src

Some project is managed by git-lfs, we need to extent magit

#+begin_src emacs-lisp
  (use-package magit-lfs
    :after (magit))
#+end_src

** =undo-tree=

I like tree-based undo management. I only rarely need it, but when I do, oh boy.

#+begin_src emacs-lisp
  (use-package undo-tree
    :custom
    (global-undo-tree-mode t)
    (undo-tree-auto-save-history nil)
    (undo-tree-visualizer-relative-timestamps t)
    (undo-tree-visualizer-timestamps t))
#+end_src

** =GDB=

using Realgud to debug source code

#+BEGIN_SRC emacs-lisp
  (use-package realgud
    :custom
    (realgud:pdb-command-name "python -m pdb"))
#+END_SRC

** Shell config

Indent with 2 spaces.

#+BEGIN_SRC emacs-lisp
  (add-hook 'sh-mode-hook
            (lambda ()
              (setq sh-basic-offset 2
                    sh-indentation 2)))
#+END_SRC

Force open shell in the current buffer
#+BEGIN_SRC emacs-lisp
  (push (cons "\\*shell\\*" display-buffer--same-window-action) display-buffer-alist)
#+END_SRC

#+begin_src emacs-lisp
  (setq comint-buffer-maximum-size 20000)
  (setq comint-prompt-read-only nil) ;; If non-nil, the comint prompt is read only.
  (setq read-process-output-max (* 1024 1024))
  (setq process-adaptive-read-buffering nil)
#+end_src

*** bash-completion

Add shell completion
#+BEGIN_SRC emacs-lisp
  (use-package bash-completion
    :config (bash-completion-setup)
    :custom
    (bash-completion-process-timeout 0.1))
#+END_SRC

*** user define

Get environment variable in Shell and set them to Emacs
#+begin_src emacs-lisp
  (defun my/get-shell-env-value-and-set-emacs ()
  ; get environment variable form shell and set to emacs
    (interactive)
    (let ((env-var '("PATH" "LD_LIBRARY_PATH" "PYTHONPATH")))
      (mapcar #'shell-copy-environment-variable env-var)
      (setq python-shell-process-environment
            (mapcar (lambda (x) (format "%s=%s" x (getenv x)))
                    env-var))))
  (define-key shell-mode-map (kbd "C-c x") 'my/get-shell-env-value-and-set-emacs)
#+end_src

** Workgroups another way to organize workspace

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'winner-mode)
    (winner-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package workgroups2
    :custom
    (wg-session-file "~/.emacs.d/.emacs_workgroups")
    (wg-prefix-key (kbd "C-c z"))
    :bind
    ("M-s s" . wg-switch-to-workgroup)
    :config
    (defun wg-open-session () t)
    (defun wg-save-session (&optional workgroup-name) t)
    (defun wg-workgroup-names ()
      "Get all workgroup names."
      (mapcar (lambda (group)
                ;; re-shape group for `completing-read'
                (cons (wg-workgroup-name group) group))
              (wg-workgroup-list)))
    (defun wg-create-workgroup (name)
      "Create and add a workgroup named NAME."
      (interactive (list (wg-read-new-workgroup-name)))
      (wg-switch-to-workgroup-internal (wg-make-and-add-workgroup name))
      ;; I prefer simpler UI
      (message "Workgroup \"%s\" was created." name))
    (defun wg-open-workgroup (&optional group-name)
      "Open specific workgroup by GROUP-NAME."
      (interactive)
      (let ((group-names (wg-workgroup-names)))
        (cond
         (group-names
          (unless group-name
            (setq group-name
                  (completing-read "Select work group: " group-names)))
          (when group-name
            (wg-open-session)
            (wg-switch-to-workgroup-internal group-name)))
         (t
          (message "No workgroup is created yet.")))))
    (defun my/wg-perform-session-maintenance ()
      (when (and (wg-minibuffer-inactive-p) workgroups-mode)
        (wg-perform-session-maintenance)))
    (workgroups-mode 1)
    (wg-reset-internal (wg-make-session))
    :hook
    (window-configuration-change . my/wg-perform-session-maintenance))
#+END_SRC

** Bazel

Bazel is a build system created by Google:

#+BEGIN_SRC emacs-lisp
  (use-package bazel
    :defer t)
#+END_SRC

** imenu-list

show function and variable tree in side buffer
#+BEGIN_SRC emacs-lisp
  (use-package imenu-list
    :init
    (use-package nav-flash)
    :bind ("C-c i" . imenu-list-smart-toggle)
    :config
    (setq imenu-list-focus-after-activation t)
    (setq imenu-list-auto-update nil)
    :hook
    (imenu-after-jump . nav-flash-show))
#+END_SRC

** ELF

read elf symbols

#+begin_src emacs-lisp
  (use-package elf-mode
    :demand
    :config
    (elf-setup-default))
#+end_src

#+begin_src emacs-lisp
  (use-package demangle-mode
    :config
    (advice-add 'elf-mode :after 'demangle-mode))
#+end_src

** UML

#+begin_src emacs-lisp
  (use-package plantuml-mode
    :mode "\\.plantuml$"
    :config
    ;; not promote to `utxt`.
    (defun plantuml-jar-output-type-opt (output-type)
      "Create the flag to pass to PlantUML according to OUTPUT-TYPE."
      (concat "-t" output-type))
    (setq plantuml-jar-path "~/.emacs.d/plantuml.jar")
    (when (file-exists-p plantuml-jar-path)
      (setq plantuml-default-exec-mode 'jar))
    (add-to-list
     'org-src-lang-modes '("plantuml" . plantuml)))
#+end_src

** Tramp

#+begin_src emacs-lisp
  (setq tramp-remote-shell "/bin/bash")
  (setq explicit-shell-file-name "/bin/bash")  ;; using bash by default.
  (setq shell-file-name "/bin/bash")  ;; using bash by default.
#+end_src

** Gerrit

#+begin_src emacs-lisp
  (use-package gerrit
    :custom
    (gerrit-use-ssl nil)
    (gerrit-host "gerrit.houmo.ai") ;; is needed for REST API calls
    :config
    (setq gerrit-dashboard-query-alist
          '(("Has draft comments" . "has:draft")
            ("Work in progress" . "is:open owner:self is:wip")
            ("Outgoing reviews" . "is:open owner:self -is:wip -is:ignored")
            ("Incoming reviews" . "is:open -owner:self -is:wip -is:ignored (reviewer:self OR assignee:self)")
            ("CCed on" . "is:open -is:ignored cc:self")
            ("toolchain/hmcc" . "project:toolchain/hmcc is:open limit:15")
            ("Recently closed" . "is:closed -is:ignored (-is:wip OR owner:self) (owner:self OR reviewer:self OR assignee:self OR cc:self) limit:15")))

    (progn
      (global-set-key (kbd "C-x i") 'gerrit-upload-transient)
      (global-set-key (kbd "C-x o") 'gerrit-download)))
#+end_src

* Programming customization
** Look for executables in =/usr/local/bin=.

Add system path to emacs.

#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'darwin)
      (mapcar #'my/append-to-path
              '("/usr/local/bin"
                "/Library/TeX/texbin"
                "/usr/local/opt/llvm/bin/")))
#+END_SRC

** common settings
*** editing

I like shallow indentation, but tabs are displayed as 8 characters by default.
This reduces that.

#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 4)
#+END_SRC

Treating terms in CamelCase symbols as separate words makes editing a little
easier for me, so I like to use =subword-mode= everywhere.

#+BEGIN_SRC emacs-lisp
  (use-package subword
    :config (global-subword-mode 1))
#+END_SRC

Compilation output goes to the =*compilation*= buffer. I rarely have that window
selected, so the compilation output disappears past the bottom of the window.
This automatically scrolls the compilation window so I can always see the
output.

#+BEGIN_SRC emacs-lisp
  (setq compilation-scroll-output t)
#+END_SRC

Use =smartparens=
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :config
    (smartparens-global-mode 1))
#+END_SRC

*** eglot LSP and more

Emacs Polyglot: an Emacs LSP client that stays out of your way.

#+begin_src emacs-lisp
  (defun my/test-then-add-eglot (mode-list program &optional command)
    (when (executable-find program)
      (if command
          (add-to-list 'eglot-server-programs
                       (list mode-list program command))
        (add-to-list 'eglot-server-programs
                     (list mode-list program)))
      (mapcar
       #'(lambda (sym)
           (eval `(add-hook
                   (quote ,(intern (concat (symbol-name sym) "-hook")))
                   'eglot-ensure)))
       mode-list)))
#+end_src

#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :pin gnu
    :init
    (package-install 'eglot t) ;; install the latest gnu-eglot
    (use-package consult-eglot)
    :commands
    (eglot eglot-ensure)
    ;; :hook
    ;; (eglot-managed-mode . (lambda () (eglot-inlay-hints-mode -1)))
    :bind (:map eglot-mode-map
                ("C-M-\\" . eglot-format)
                ("C-c e r" . eglot-rename)
                ("C-c e a" . eglot-code-actions)
                ("C-c e c" . eglot-reconnect)
                ("C-c e k" . eglot-shutdown)
                ("C-c e s" . consult-eglot-symbols)
                ("C-c e i" . eglot-inlay-hints-mode))
    :custom
    ;; (eglot-autoshutdown t)
    (eglot-events-buffer-size 0)
    :config
    (my/test-then-add-eglot '(c-or-c++-mode c-mode c++-mode c++-ts-mode c-ts-mode) "clangd")
    (my/test-then-add-eglot '(python-mode python-ts-mode) "pyright-langserver" "--stdio")
    (my/test-then-add-eglot '(LaTeX-mode tex-mode context-mode texinfo-mode bibtex-mode) "texlab")
    (my/test-then-add-eglot '(javascript-mode js-ts-mode) "typescript-language-server" "--stdio")
    (my/test-then-add-eglot '(sh-mode bash-ts-mode) "bash-language-server" "start")
    (my/test-then-add-eglot '(rust-ts-mode) "rust-analyzer")
    (my/test-then-add-eglot '(yaml-ts-mode) "yaml-language-server" "--stdio")
    (my/test-then-add-eglot '(dockerfile-ts-mode) "docker-langserver" "--stdio")
    ;; (my/test-then-add-eglot '(json-ts-mode) "vscode-json-language-server" "--stdio")
    (my/test-then-add-eglot '(mlir-mode) "mlir-lsp-server")

    (defun eglot-tblgen-command-args (interactive-p)
      (let* ((build-directory (project-cmake-build-directory))
             (database (expand-file-name "tablegen_compile_commands.yml"
                                         build-directory)))
        (list "tblgen-lsp-server"
              (format "--tablegen-compilation-database=%s" database))))

    (when (executable-find "tblgen-lsp-server")
      (add-to-list 'eglot-server-programs
                   '((tablegen-mode) . eglot-tblgen-command-args))
      (add-hook 'tablegen-mode-hook 'eglot-ensure))
    (setq completion-category-defaults nil))
#+END_SRC

*** DAP mode

Dape is a debug adapter client for Emacs.

#+begin_src emacs-lisp
  (use-package dape ;; should use gnu-dev:version
    :custom
    (dape-buffer-window-arrangement 'right) ;; Info buffers to the right
    (dape-breakpoint-margin-string "●") ;; ◯
    :config
    (put 'dape--overlay-arrow-position
         'overlay-arrow-string   ;; ▶ →
         (propertize "▶" 'face 'dape-stack-trace-face)))
#+end_src

*** Xref jump

Use minibuffer as the interface to select from xref candidates.

#+BEGIN_SRC emacs-lisp
  (use-package xref)
#+END_SRC

*** Terminal

Emacs-libvterm (vterm) is fully-fledged terminal emulator inside GNU Emacs based
on libvterm, a C library. As a result of using compiled code (instead of elisp),
emacs-libvterm is fully capable, fast, and it can seamlessly handle large
outputs.

#+begin_src emacs-lisp
  (defun my/vterm-env ()
    (interactive)
    (setq vterm-environment (cdr (assq 'vterm-env dir-local-variables-alist))) ;; FixMe
    (vterm))

  (define-derived-mode my/vterm-mode fundamental-mode "my/VTerm"
    "Major mode for vterm buffer."
    (hack-dir-local-variables)
    (let ((vterm-env (cdr (assq 'vterm-environment dir-local-variables-alist))))
      (when vterm-env
        (make-local-variable 'vterm-environment)
        (setq vterm-environment vterm-env)))
    )
#+end_src

#+begin_src emacs-lisp
  (use-package vterm
    :init
    (put 'vterm-environment 'safe-local-variable #'listp)
    :bind ("C-c v" . vterm) ;; terminal
    :custom
    (vterm-max-scrollback 10000)
    (vterm-kill-buffer-on-exit nil)
    (vterm-always-compile-module t)
    (term-copy-exclude-prompt t)
    (vterm-buffer-name-string "*vterm %s*")
    (vterm-keymap-exceptions
     '("C-c" "C-x" "C-u" "C-g" "C-h" "C-l" "M-x" "M-o" "C-y" "M-y" "M-s")))
#+end_src

Eat: Emulate A Terminal

#+begin_src emacs-lisp
  (use-package eat
    :bind ("C-c t" . eat-new-term)
    :config
    (defun eat-new-term ()
      "Create a new Eat terminal buffer."
      (interactive)
      (eat-other-window nil '(4)))

    (defun my/eat-add-compilation-environment ()
      (hack-dir-local-variables-non-file-buffer)
      (setq-local process-environment
                  (append compilation-environment process-environment)))
    :hook
    ;; https://codeberg.org/akib/emacs-eat/issues/129
    (eat-exec . (lambda (&rest _) (eat-line-mode)))
    (eat-mode . my/eat-add-compilation-environment)

    :custom
    (eat-enable-auto-line-mode t)
    (eat-shell-prompt-annotation-failure-margin-indicator "✘ ")
    (eat-shell-prompt-annotation-running-margin-indicator "⏳")
    (eat-shell-prompt-annotation-success-margin-indicator "✔ "))
#+end_src

*** Fold and unfold code blocks

Hydra short-keys
#+begin_src emacs-lisp
  (defhydra hydra-hs (:idle 1.0)
    "
     Hide^^            ^Show^            ^Toggle^    ^Navigation^
     ----------------------------------------------------------------
     _h_ hide all      _s_ show all      _t_oggle    _n_ext line
     _d_ hide block    _a_ show block              _p_revious line
     _l_ hide level

     _SPC_ cancel _q_ cancel
     "
    ("s" hs-show-all)
    ("h" hs-hide-all)
    ("a" hs-show-block)
    ("d" hs-hide-block)
    ("t" hs-toggle-hiding)
    ("l" hs-hide-level)
    ("n" forward-line)
    ("p" (forward-line -1))
    ("SPC" nil)
    ("q" nil))
#+end_src

Emacs has a minor mode called hs-minor-mode that allows users to fold and hide blocks of text
#+BEGIN_SRC emacs-lisp
  (defun my/display-code-line-counts (ov)
    (when (eq 'code (overlay-get ov 'hs))
      (overlay-put ov 'display
                   (propertize
                    (format " … <%d>"
                            (count-lines (overlay-start ov)
                                         (overlay-end ov)))
                    'face '(:background "#ff0066" :foreground "#000000")))))

  (use-package hideshow
    :hook (prog-mode . hs-minor-mode)
    :bind (:map hs-minor-mode-map
                ("C-c @" . hydra-hs/body))
    :config
    (setq hs-set-up-overlay 'my/display-code-line-counts))
#+END_SRC

*** Highlight variables

 #+BEGIN_SRC emacs-lisp
   (use-package symbol-overlay
     :bind (("M-i" . symbol-overlay-put)
            ("M-n" . symbol-overlay-jump-next)
            ("M-p" . symbol-overlay-jump-prev)
            ("M-N" . symbol-overlay-switch-forward)
            ("M-P" . symbol-overlay-switch-backward)
            ("M-C" . symbol-overlay-remove-all))
     :hook (prog-mode . symbol-overlay-mode))
 #+END_SRC

*** Tree-sitter

using tree-sitter to manage Parser
#+begin_src emacs-lisp
  (use-package treesit
    :ensure nil
    :if (and (fboundp 'treesit-available-p) (treesit-available-p))
    :custom
    ;; (treesit-extra-load-path `(,treesit-langs-folder))
    (treesit-max-buffer-size (* 100 1024 1024))
    ;; disable checking the ‘-*-’ line, this will disable loading .dir-locals.el
    ;; (enable-local-variables nil)
    :config
    (setq major-mode-remap-alist
          (append major-mode-remap-alist
                  '((sh-mode . bash-ts-mode)
                    (javascript-mode . js-ts-mode)
                    (js-json-mode . json-ts-mode)
                    (python-mode . python-ts-mode)
                    (c-or-c++-mode . c++-ts-mode)
                    (c-mode . c-ts-mode)
                    (c++-mode . c++-ts-mode))))
    (mapcar #'require '(cmake-ts-mode
                        dockerfile-ts-mode
                        rust-ts-mode
                        yaml-ts-mode))
    :mode
    ("\\.h\\.inc\\'" . c++-ts-mode)
    ("\\.cpp\\.inc\\'" . c++-ts-mode))
#+end_src

*** Indent Highlight

#+begin_src emacs-lisp
  (use-package indent-bars
    :load-path "~/.emacs.d/indent-bars"
    :config
    (require 'indent-bars-ts)
    :custom
    (indent-bars-treesit-support t)
    (indent-bars-no-descend-string t)
    (indent-bars-treesit-scope '((python function_definition class_definition for_statement
                                         if_statement with_statement while_statement)))
    (indent-bars-treesit-ignore-blank-lines-types '("module"))
    :config
    (defun my/set-indent-bars-bg-fg ()
      (setq
       indent-bars-unspecified-fg-color (face-attribute 'default :foreground)
       indent-bars-unspecified-bg-color (face-attribute 'default :background)
       indent-bars-color '(highlight :face-bg t :blend 0.15)
       indent-bars-highlight-current-depth '(:blend 0.5) ;; pump up the BG blend on current
       ;; blend=1: blend with BG only
       indent-bars-color-by-depth '(:regexp "outline-\\([0-9]+\\)" :blend 1))
      (indent-bars-reset))

    (my/set-indent-bars-bg-fg)

    :hook ((python-base-mode c-ts-base-mode) . indent-bars-mode))
#+end_src

** Python

Pip can install binary file.

#+begin_src emacs-lisp
  (defun my/get-first-valid-path (path-list)
    ;; get build path
    ;; this dirctiry should contain the excutable server and config file.
    ;; check path validation and return list.
    (let ((path (cl-remove-if-not
                 (lambda (x)
                   (file-directory-p (eval x)))
                 path-list)))
      (if path
          (eval (car path))
        nil)))
#+end_src

#+BEGIN_SRC emacs-lisp
  (use-package virtualenvwrapper
    :config
    (venv-initialize-interactive-shells) ;; if you want interactive shell support
    (venv-initialize-eshell) ;; if you want eshell support
    (setq venv-location '("~/py3/"
                          "~/py3.10/"))
    (let ((venv-py (my/get-first-valid-path venv-location)))
      (when venv-py
        (venv-workon (car (last (split-string venv-py "\/") 2)))))
    (my/test-then-add-eglot '(cmake-ts-mode) "cmake-language-server")
    ;; (my/test-then-add-eglot '(python-mode python-ts-mode) "pylsp")
    )
#+END_SRC

Set ipython as interpreter

#+BEGIN_SRC emacs-lisp
  (use-package python
    :config
    (put 'python-shell-process-environment 'safe-local-variable #'listp)
    :custom
    (python-shell-completion-native-enable nil)
    (python-shell-interpreter "ipython")
    (python-shell-interpreter-args "--simple-prompt -i")
    (py-ipython-command-args "--simple-prompt -i")
    (python-indent-offset 4)
    :hook
    (python-mode . (lambda ()
                     (setq indent-tabs-mode nil)
                     (setq python-indent 4)
                     (setq tab-width 4))))
#+END_SRC

#+begin_src emacs-lisp
  (use-package cython-mode)
#+end_src

*** COMMENT using Jupyter

#+BEGIN_SRC emacs-lisp
  (use-package ein
    :config
    (require 'ein-notebook)
    (setq ein:cell-max-num-outputs 10)
    :commands (ein:notebooklist-open))
#+END_SRC

*** code format

#+begin_src emacs-lisp
  (defun my/python-format ()
    (interactive)
    (if (region-active-p)
        (python-black-partial-dwim)
      (python-black-buffer)))

  (defun my/python-format-key ()
    (define-key (current-local-map) [remap eglot-format] 'my/python-format)
    (local-set-key (kbd "C-M-\\") 'my/python-format))

  (use-package python-black
    :if (executable-find "black")
    :init
    (put 'python-black-extra-args 'safe-local-variable #'listp)
    :after python
    :hook
    (python-mode . my/python-format-key)
    (python-ts-mode . my/python-format-key))
#+end_src

** C++

LLVM-format-style

#+begin_src emacs-lisp
  (defun llvm-lineup-statement (langelem)
    (let ((in-assign (c-lineup-assignments langelem)))
      (if (not in-assign)
          '++
        (aset in-assign 0
              (+ (aref in-assign 0)
                 (* 2 c-basic-offset)))
        in-assign)))

  ;; Add a cc-mode style for editing LLVM C and C++ code
  (c-add-style "llvm.org"
               '("gnu"
                 (fill-column . 80)
                 (c++-indent-level . 2)
                 (c-basic-offset . 2)
                 (indent-tabs-mode . nil)
                 (c-offsets-alist . ((arglist-intro . ++)
                                     (innamespace . 0)
                                     (member-init-intro . ++)
                                     (statement-cont . llvm-lineup-statement)))))
#+end_src



clang-format
OVERVIEW: A tool to format C/C++/Java/JavaScript/Objective-C/Protobuf/C# code.

#+begin_src emacs-lisp
  (defun my/clang-format (&optional beg end)
    (interactive
     (and (region-active-p) (list (region-beginning) (region-end))))
    (if (and beg end)
        (clang-format beg end)
      (clang-format-buffer)))

  (defun my/clang-format-key ()
    (when (current-local-map)
      (define-key (current-local-map) [remap eglot-format] 'my/clang-format))
    (local-set-key (kbd "C-M-\\") 'my/clang-format))

  (use-package clang-format
    :if (executable-find "clang-format")
    :custom
    (clang-format-fallback-style "llvm")
    :hook ((c-mode c++-mode java-mode js-mode tablegen-mode c++-ts-mode c-ts-mode) .
           my/clang-format-key))
#+end_src

Google Test
For running Google Tests from a given buffer

#+BEGIN_SRC emacs-lisp
  (use-package gtest-mode
    :load-path "~/.emacs.d/third_party/danielmartin-gtest"
    :after cc-mode)
#+END_SRC

** Rust

#+begin_src emacs-lisp
  (use-package rust-playground
    :bind
    ("C-x r p" . rust-playground)
    :config
    (add-to-list 'project-vc-extra-root-markers "Cargo.toml")
    (defun rust-playground ()
      "Run playground for Rust language in a new buffer."
      (interactive)
      ;; get the dir name
      (let* ((snippet-dir (rust-playground-dir-name))
             (snippet-file-name (rust-playground-snippet-main-file-name snippet-dir))
             (snippet-cargo-toml (rust-playground-toml-file-name snippet-dir)))
        ;; create a buffer for Cargo.toml and switch to it
        (make-directory snippet-dir t)
        (set-buffer (create-file-buffer snippet-cargo-toml))
        (set-visited-file-name snippet-cargo-toml t)
        (rust-playground-mode)
        (rust-playground-insert-template-head "snippet of code" snippet-dir)
        (insert rust-playground-cargo-toml-template)
        (save-buffer)
        ;;now do src/main.rs
        (make-directory (concat snippet-dir "src"))
        (let ((new-buffer (create-file-buffer snippet-file-name)))
          (set-buffer new-buffer)
          (set-visited-file-name snippet-file-name t)
          (rust-playground-insert-template-head "snippet of code" snippet-dir)
          (insert rust-playground-main-rs-template)
          (save-buffer)
          (switch-to-buffer new-buffer)
          ;; back up to a good place to edit from
          (backward-char 27)
          (insert-tab))
        (rust-playground-mode))))
#+end_src

** COMMENT Coq

Use =company-coq-mode=, which really helps make Proof General a more useful IDE.

I also like to disable =abbrev-mode=; it has a ton of abbreviations for Coq, but
they've always been unpleasant surprises for me.

#+BEGIN_SRC emacs-lisp
  (use-package company-coq
    :init
    (add-hook 'coq-mode-hook
              (lambda ()
                (company-coq-mode)
                (abbrev-mode 0)))
    :requires proof-general)
#+END_SRC

The default Proof General layout stacks the code, goal, and response buffers on
top of each other. I like to keep my code on one side and my goal and response
buffers on the other.

#+BEGIN_SRC emacs-lisp
  (setq proof-three-window-mode-policy 'hybrid)
#+END_SRC

The Proof General splash screen's pretty cute, but I don't need to see it every
time.

#+BEGIN_SRC emacs-lisp
  (setq proof-splash-enable nil)
#+END_SRC

** COMMENT Haskell

Enable =haskell-doc-mode=, which displays the type signature of a function, and
use smart indentation.

#+BEGIN_SRC emacs-lisp
  ;;  (my/append-to-path "~/.cabal/bin")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :init
    (add-hook 'haskell-mode-hook
              (lambda ()
                (haskell-doc-mode)
                (interactive-haskell-mode)
                (turn-on-haskell-indent))))
#+END_SRC

** JavaScript and CoffeeScript

Indent everything by 2 spaces.

#+BEGIN_SRC emacs-lisp
  (setq js-indent-level 2)

  (add-hook 'coffee-mode-hook
            (lambda ()
              (yas-minor-mode 1)
              (setq coffee-tab-width 2)))
#+END_SRC

** Lisps

=rainbow-delimiters= is convenient for coloring matching parentheses.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook ((emacs-lisp-mode lisp-mode racket-mode) . rainbow-delimiters-mode))
#+end_src

If I'm writing in Emacs lisp I'd like to use =eldoc-mode= to display
documentation.

#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :config
    (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
    (setq eldoc-idle-delay 10))
#+END_SRC

** scheme

#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :config
    (setq geiser-active-implementations '(mit chicken guile racket chez)))
#+END_SRC

** =web-mode=

If I'm in =web-mode=, I'd like to:

- Color color-related words with =rainbow-mode=.
- Still be able to run RSpec tests from =web-mode= buffers.
- Indent everything with 2 spaces.

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :init
    (use-package rainbow-mode)
    (use-package rspec-mode)
    :config
    (add-hook 'web-mode-hook 'rainbow-mode)
    (add-hook 'web-mode-hook 'rspec-mode)
    (setq web-mode-markup-indent-offset 2)
    :mode "\\.erb$"
           "\\.html$"
           "\\.php$"
           "\\.rhtml$")
#+END_SRC

Use =web-mode= with embedded Ruby files, regular HTML, and PHP.

** FlatBuffer

#+begin_src emacs-lisp
  (use-package flatbuffers-mode)
#+end_src

** ProtoBuffer

add Google protocol buffer support
#+begin_src emacs-lisp
  (defun my/prototxt-mode-hook ()
    (when (and (stringp buffer-file-name)
               (string-match "\\.prototxt\\'" buffer-file-name))
      (setq-local comment-start "# ")
      (setq-local comment-start-skip "#+\\s-*")
      (font-lock-add-keywords nil
                              '(("#.+" . font-lock-comment-face)))))
#+end_src

#+BEGIN_SRC emacs-lisp
  (use-package protobuf-mode
    :mode "\\.prototxt$"
    :hook
    (protobuf-mode . my/prototxt-mode-hook))
#+END_SRC

** ReStructuredText

#+BEGIN_SRC emacs-lisp
  (use-package rst)
#+END_SRC

** LLVM mode

These are syntax highlighting files for the Emacs and XEmacs editors.
#+begin_src emacs-lisp
  (use-package llvm-mode
    :mode "\\.ll$"
    :load-path "~/.emacs.d/third_party/llvm-mode+")
#+end_src

#+begin_src emacs-lisp
  (use-package tablegen-mode
    :mode "\\.td$"
    :load-path "~/.emacs.d/third_party/llvm-mode+"
    :hook
    (tablegen-mode . display-line-numbers-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package mlir-mode
    :mode "\\.pdll$" "\\.mlir$"
    :load-path "~/.emacs.d/third_party/llvm-mode+")
#+end_src

** Groovy mode

#+begin_src emacs-lisp
  (use-package groovy-mode
    :config
    (let ((groovy-lsp "/usr/local/lib/groovy-language-server-all.jar"))
      (when (file-exists-p groovy-lsp)
        (add-to-list 'eglot-server-programs
                     `(groovy-mode . ("java" "-jar" ,groovy-lsp)))
        (add-hook 'groovy-mode-hook 'eglot-ensure))))
#+end_src

** Lua mode

#+begin_src emacs-lisp
  (use-package lua-mode)
#+end_src

** JQ mode

jq is a lightweight and flexible command-line JSON processor akin to
sed,awk,grep, and friends for JSON data.

#+begin_src emacs-lisp
  (use-package jq-mode
    :bind ("C-c C-j" . jq-interactively)
    :mode
    ("\\.jq$" . jq-mode))
#+end_src

** EPUB mode

#+begin_src emacs-lisp
  (use-package nov
    :mode
    ("\\.epub\\'" . nov-mode))
#+end_src

** ChatGPT

#+begin_src emacs-lisp
  (defun my/internet-up-p (&optional host)
    (= 0 (call-process "ping" nil nil nil "-c" "1" "-W" "1"
                       (if host host "www.wikipedia.org"))))
#+end_src

#+begin_src emacs-lisp
  (use-package gptel
    :bind (("C-c RET" . gptel-send)
           ("C-c <return>" . gptel-send)
           ("C-c C-<return>" . gptel-menu)
           :map gptel-mode-map
           ("C-c C-x t" . gptel-set-topic))
    :config
    ;; (setq gptel--debug t)
    (setq gptel-default-mode 'org-mode)
    (unless (my/internet-up-p)
      (setq-default gptel-proxy
                    (format "socks5h://%s" my/socks-proxy)))

    (gptel-make-openai "ChatGPT"
      :key 'gptel-api-key
      :stream t
      :models '("gpt-4o"))

    (defvar gptel--gemini
      (gptel-make-gemini "Gemini"
        :key 'gptel-api-key
        :stream t
        :models '("gemini-1.5-pro-latest")))

    (defvar gptel--anthropic
      (gptel-make-anthropic "Claude"
        :key 'gptel-api-key
        :stream t
        :models '("claude-3-5-sonnet-20240620")))

    (setq-default gptel-backend gptel--gemini
                  gptel-model "gemini-1.5-pro-latest")
    :custom
    (gptel-curl-file-size-threshold 2000000)
    (gptel-use-curl t)
    (gptel-playback t))
#+end_src

** BuildBot

#+begin_src emacs-lisp
  (use-package buildbot)
#+end_src

** Graphviz-dot

#+begin_src emacs-lisp
  (use-package graphviz-dot-mode
    :config
    (setq graphviz-dot-indent-width 4))
#+end_src

* Org

Including org-tempo restores the <s-style easy-templates that were deprecated in Org 9.2.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure org-contrib
    :config
    (put 'narrow-to-region 'disabled nil)
    (setq org-modules (cl-remove-duplicates
                       (append org-modules
                               '(org-tempo
                                 ox-md
                                 ox-beamer
                                 org-capture
                                 ox-latex
                                 ox-odt
                                 org-gnus))))
    (bind-keys*
     ("C-c l" . org-store-link)
     ("C-c C-l" .  org-insert-link)))
#+END_SRC

I’d like the initial scratch buffer to be in Org:

#+BEGIN_SRC emacs-lisp
  (setq initial-major-mode 'org-mode)
#+END_SRC

** Display preferences

I like to see an outline of pretty bullets instead of a list of asterisks.

#+BEGIN_SRC emacs-lisp
  (defun my/change-cdr-value (in-list key value)
    (when (consp in-list)
      (if (eq (car in-list) key)
          (setcdr in-list value)
        (progn
          (my/change-cdr-value (car in-list) key value)
          (my/change-cdr-value (cdr in-list) key value))
        )))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :config
    (add-hook 'org-mode-hook 'org-bullets-mode))
#+END_SRC

I like seeing a little downward-pointing arrow instead of the usual ellipsis
(=...=) that org displays when there's stuff under a header.

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "…")
#+END_SRC

Use syntax highlighting in source blocks while editing.

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

Make TAB act as if it were issued in a buffer of the language's major mode.

#+BEGIN_SRC emacs-lisp
  (setq org-src-tab-acts-natively t)
#+END_SRC

When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC

Using build-in hide leading starts

#+BEGIN_SRC emacs-lisp
  (setq org-hide-leading-stars t)
  (setq org-pretty-entities t)
  (setq org-allow-promoting-top-level-subtree t)
  (setq org-email-link-description-format "%c: %.50s")
#+END_SRC

Wrap long text lines.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'visual-line-mode)
#+END_SRC

** Key-bindings

Bind a few handy keys.

#+BEGIN_SRC emacs-lisp
  (define-key global-map "\C-ca" 'org-agenda)
  (define-key global-map "\C-cc" 'org-capture)
  (define-key global-map "\C-cL" 'org-occur-link-in-agenda-files)
  (define-key global-map "\C-c+" 'org-increase-number-at-point)
  (define-key global-map "\C-c-" 'org-decrease-number-at-point)
#+END_SRC

Hit =C-c g= to quickly open up my todo list.

#+BEGIN_SRC emacs-lisp
  (defun open-gtd-file ()
    "Open the master org TODO list."
    (interactive)
    ;; (my/copy-tasks-from-inbox)
    (find-file org-gtd-file)
    (end-of-buffer))

  (global-set-key (kbd "C-c g") 'open-gtd-file)
#+END_SRC


Hit =M-n= to quickly open up a capture template for a new todo.

#+BEGIN_SRC emacs-lisp
  (defun org-capture-todo ()
    (interactive)
    (org-capture :keys "t"))
#+END_SRC

#+begin_src emacs-lisp
  (setq org-special-ctrl-a/e 'reversed)
  (setq org-special-ctrl-k t)
  (setq org-support-shift-select t)
#+end_src

** COMMENT Timing

Set headlines to STRT and clock-in when running a countdown

#+BEGIN_SRC emacs-lisp
  (org-clock-persistence-insinuate)
  (setq org-clock-display-default-range 'thisweek)
  (setq org-clock-persist t)
  (setq org-clock-idle-time 60)
  (setq org-clock-history-length 35)
  (setq org-clock-in-resume t)
  (setq org-clock-out-remove-zero-time-clocks t)
  (org-agenda-to-appt)
  (add-hook 'org-timer-set-hook
            (lambda ()
              (if (eq major-mode 'org-agenda-mode)
                  (call-interactively 'org-agenda-clock-in)
                (call-interactively 'org-clock-in))))
  (add-hook 'org-timer-done-hook
            (lambda ()
              (if (and (eq major-mode 'org-agenda-mode)
                       org-clock-current-task)
                  (call-interactively 'org-agenda-clock-out)
                (call-interactively 'org-clock-out))))
  (add-hook 'org-timer-pause-hook
            (lambda ()
              (if org-clock-current-task
                  (if (eq major-mode 'org-agenda-mode)
                      (call-interactively 'org-agenda-clock-out)
                    (call-interactively 'org-clock-out)))))
  (add-hook 'org-timer-stop-hook
            (lambda ()
              (if org-clock-current-task
                  (if (eq major-mode 'org-agenda-mode)
                      (call-interactively 'org-agenda-clock-out)
                    (call-interactively 'org-clock-out)))))
#+END_SRC

*** COMMENT icalendar

#+BEGIN_SRC emacs-lisp
  (setq org-combined-agenda-icalendar-file "~/.Org/my.ics")
  (setq org-icalendar-combined-name "My ORG")
  (setq org-icalendar-use-scheduled '(todo-start event-if-todo event-if-not-todo))
  (setq org-icalendar-use-deadline '(todo-due event-if-todo event-if-not-todo))
  (setq org-icalendar-timezone "China/Beijing")
  (setq org-icalendar-store-UID t)
#+END_SRC

** GTD

Store my org files in =~/org=, maintain an inbox in Dropbox, define the location
of an index file (my main todo list), and archive finished tasks in
=~/org/archive.org=.

#+BEGIN_SRC emacs-lisp
  (use-package org-pomodoro)
#+END_SRC

*** Keywords
#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/.Org")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (let ((fun (lambda (x)
                 (concat (file-name-as-directory org-directory) x))))
      (if (listp filename)
          (mapcar fun filename)
        (eval (list fun filename)))))

  (setq org-gtd-file (org-file-path "gtd.org"))
  (setq org-default-notes-file (org-file-path "note.org"))
  (setq org-scheduled-past-days 100)
  (setq org-stuck-projects '("+LEVEL=1" ("NEXT" "TODO" "DONE")))
  (setq org-tag-persistent-alist '(("Write" . ?w) ("Read" . ?r)))
  (setq org-tag-alist
        '((:startgroup)
          ("Handson" . ?o)
          (:grouptags)
          ("Write" . ?w) ("Code" . ?c) ("Tel" . ?t)
          (:endgroup)
          (:startgroup)
          ("Handsoff" . ?f)
          (:grouptags)
          ("Read" . ?r) ("View" . ?v) ("Listen" . ?l)
          (:endgroup)
          ("Mail" . ?@) ("Search" . ?s) ("Buy" . ?b)))
  (setq org-tags-column -74)
  (setq org-todo-keywords '((type "TODO" "STRT" "NEXT" "WAIT" "|" "DONE" "DELEGATED" "CANCELED")))
  (setq org-todo-repeat-to-state t)
  (setq org-use-property-inheritance t)
  (setq org-use-sub-superscripts nil)
  (setq org-todo-keyword-faces
        '(("STRT" . (:foreground "white" :inverse-video t))
          ("NEXT" . (:foreground "brightcyan" :weight bold))
          ("WAIT" . (:foreground "#889699" :inverse-video t))
          ("CANCELED" . (:foreground "#889699"))))
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
  (setq org-deadline-warning-days 7)
#+END_SRC

*** Capturing

Define a few common tasks as capture templates. Specifically

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("C" "Misc [inbox]" entry (file "~/.Org/inbox.org")
           "* TODO %a\n  :PROPERTIES:\n  :CAPTURED: %U\n  :END:\n"
           :prepend t :immediate-finish t)

          ("c" "Misc [inbox] (edit)" entry (file "~/.Org/inbox.org")
           "* TODO %?\n  :PROPERTIES:\n  :CAPTURED: %U\n  :END:\n\n- %a" :prepend t)

          ("r" "RDV Perso" entry (file+headline "~/.Org/rdv.org" "RDV Perso")
           "* RDV avec %:fromname %?\n  :PROPERTIES:\n  :CAPTURED: %U\n  :END:\n\n- %a" :prepend t)

          ("R" "RDV Etalab" entry (file+headline "~/.Org/rdv-etalab.org" "RDV Etalab")
           "* RDV avec %:fromname %?\n  :PROPERTIES:\n  :CAPTURED: %U\n  :END:\n\n- %a" :prepend t)

          ("t" "Tickler" entry (file+headline "~/.Org/tickler.org" "Tickler")
           "* %i%? \n  :PROPERTIES:\n  :CAPTURED: %U\n  :END:\n\n- %a\n\n%i" :prepend t)))

  (setq org-capture-templates-contexts
        '(("r" ((in-mode . "gnus-summary-mode")
                (in-mode . "gnus-article-mode")
                (in-mode . "message-mode")))
          ("R" ((in-mode . "gnus-summary-mode")
                (in-mode . "gnus-article-mode")
                (in-mode . "message-mode")))))
#+END_SRC

*** Refine & Archive

set org-refile level deep to max 3

#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets '((("~/.Org/gtd.org") . (:maxlevel . 3))
                             (("~/.Org/someday.org") . (:maxlevel . 1))
                             (("~/.Org/tickler.org") . (:maxlevel . 2))))

  (setq org-refile-use-outline-path 'file)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-cache nil)
  (setq org-reverse-note-order t)
  (setq org-outline-path-complete-in-steps nil)
  ;; (setq org-archive-default-command 'org-archive-to-archive-sibling)
#+END_SRC

Hitting =C-c C-x C-s= will mark a todo as done and move it to an appropriate
place in the archive.

#+BEGIN_SRC emacs-lisp
  (setq org-archive-location
        (concat (org-file-path "archive.org") "::datetree/"))

  (defun my/mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it."
    (interactive)
    (let ((ts (org-get-todo-state)))
      (when (not (or (equal ts "DONE")
                     (equal ts "DELEGATED")
                     (equal ts "CANCELLED")))
        (org-todo 'done)))
    (org-archive-subtree))

  (define-key org-mode-map (kbd "C-c C-x C-s") 'my/mark-done-and-archive)
#+END_SRC

Record the time that a todo was archived.

#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC

auto save org file
#+BEGIN_SRC emacs-lisp
  (advice-add 'org-archive-subtree :after 'org-save-all-org-buffers)
  (advice-add 'org-agenda-quit :before 'org-save-all-org-buffers)
#+END_SRC

*** Agenda

#+begin_src emacs-lisp
  (use-package org-super-agenda)
#+end_src


#+BEGIN_SRC emacs-lisp
  ;; Set headlines to STRT when clocking in
  (add-hook 'org-clock-in-hook (lambda() (org-todo "STRT")))
  ;; (setq org-agenda-diary-file "/home/guerry/org/rdv.org")
  (setq org-agenda-dim-blocked-tasks nil)
  (setq org-log-into-drawer "LOGBOOK")
  (setq org-agenda-entry-text-maxlines 10)
  (setq org-timer-default-timer 25)
  (setq org-agenda-diary-file (org-file-path '("rdv.org" "gtd.org" "inbox.org")))
  (setq org-agenda-files (org-file-path '("inbox.org" "gtd.org" "tickler.org" "someday.org")))
  (setq org-agenda-prefix-format
        '((agenda . " %i %-12:c%?-14t%s")
          (timeline . "  % s")
          (todo . " %i %-14:c")
          (tags . " %i %-14:c")
          (search . " %i %-14:c")))
  (setq org-agenda-restore-windows-after-quit t)
  (setq org-agenda-show-inherited-tags nil)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-timestamp-if-done t)
  (setq org-agenda-sorting-strategy
        '((agenda time-up) (todo time-up) (tags time-up) (search time-up)))
  (setq org-agenda-tags-todo-honor-ignore-options t)
  (setq org-agenda-use-tag-inheritance nil)
  (setq org-agenda-window-frame-fractions '(0.0 . 0.5))
  (setq org-agenda-deadline-faces
        '((1.0001 . org-warning)              ; due yesterday or before
          (0.0    . org-upcoming-deadline)))  ; due today or later
#+END_SRC

*** Review

list stuck projects
#+BEGIN_SRC emacs-lisp
  (setq org-stuck-projects
        '("TODO={.+}/-DONE" nil nil "SCHEDULED:\\|DEADLINE:"))
#+END_SRC

using priority to organize my life
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-custom-commands
        `(
          ;; Week agenda for rendez-vous and tasks
          ("%" "Rendez-vous" agenda* "Week planning"
           ((org-agenda-span 'week)
            (org-agenda-files (org-file-path '("rdv.org")))
            ;; (org-deadline-warning-days 3)
            (org-agenda-sorting-strategy
             '(todo-state-up time-up priority-down))))

          ("!" tags-todo "+DEADLINE<=\"<+7d>\"")
          ("=" tags-todo "+SCHEDULED<=\"<now>\"")
          ("?" "WAIT (gtd)" tags-todo "TODO={WAIT}"
           ((org-agenda-files (org-file-path '("gtd.org")))
            (org-agenda-sorting-strategy
             '(todo-state-up priority-down time-up))))
          ("@" tags-todo "+Mail+TODO={NEXT\\|STRT\\|WAIT}")

          ("w" "Report DONE/CANCELED/DELEGATED"
           agenda ""
           ((org-agenda-span 'week)
            (org-agenda-start-on-weekday 0)
            (org-agenda-start-with-log-mode '(closed state clock))
            (org-agenda-files (org-file-path '("gtd.org" "archive.org")))
            (org-agenda-skip-function
             '(org-agenda-skip-entry-if 'nottodo 'done))
            (org-agenda-sorting-strategy '(timestamp-up))))

          ("" . "Task and rendez-vous for today")
          ("" "Travail (tout)" agenda "Tasks and rdv for today"
           ((org-agenda-span 1)
            (org-agenda-files (org-file-path '("gtd.org" "my.org")))
            (org-deadline-warning-days 3)
            (org-agenda-sorting-strategy
             '(todo-state-up time-up priority-down))))
          (" " "Libre (tout)" agenda "Tasks and rdv for today"
           ((org-agenda-span 1)
            (org-agenda-files (org-file-path '("libre.org")))
            (org-deadline-warning-days 3)
            (org-agenda-sorting-strategy
             '(todo-state-up priority-down time-up))))
          ("e" "Etalab TODO" tags-todo "TODO={STRT\\|NEXT\\|TODO}"
           ((org-agenda-files (org-file-path '("libre.org")))
            (org-agenda-category-filter-preset '("+ETL"))
            (org-agenda-sorting-strategy
             '(todo-state-up time-up priority-down))))

          ("n" "NEXT action" tags-todo "TODO={NEXT\\|STRT}"
           ((org-agenda-files (org-file-path '("gtd.org")))
            (org-agenda-sorting-strategy
             '(todo-state-down time-up priority-down))))

          ("x" . "Scheduled for today")
          ("xx" "Agenda work" agenda "Work scheduled for today"
           ((org-agenda-span 1)
            (org-deadline-warning-days 3)
            (org-agenda-entry-types '(:timestamp :scheduled))
            (org-agenda-sorting-strategy
             '(todo-state-up priority-down time-up))))
          ("xX" "Agenda libre" agenda "Libre scheduled for today"
           ((org-agenda-span 1)
            (org-deadline-warning-days 3)
            (org-agenda-files (org-file-path '("libre.org")))
            (org-agenda-entry-types '(:timestamp :scheduled))
            (org-agenda-sorting-strategy
             '(todo-state-up priority-down time-up))))

          ("z" . "Deadlines for today")
          ("zz" "Work deadlines" agenda "Past/upcoming work deadlines"
           ((org-agenda-span 1)
            (org-deadline-warning-days 15)
            (org-agenda-entry-types '(:deadline))
            (org-agenda-sorting-strategy
             '(todo-state-up priority-down time-up))))
          ("zZ" "Libre deadlines" agenda "Past/upcoming leisure deadlines"
           ((org-agenda-span 1)
            (org-deadline-warning-days 15)
            (org-agenda-files (org-file-path '("libre.org")))
            (org-agenda-entry-types '(:deadline))
            (org-agenda-sorting-strategy
             '(todo-state-up priority-down time-up))))

          ("r" . "Read")
          ("rr" tags-todo "+Read+TODO={NEXT\\|STRT}")
          ("rR" tags-todo "+Read+TODO={NEXT\\|STRT}"
           ((org-agenda-files '("~/org/libre.org"))))
          ("v" . "View")
          ("vv" tags-todo "+View+TODO={NEXT\\|STRT}")
          ("vV" tags-todo "+View+TODO={NEXT\\|STRT}"
           ((org-agenda-files (org-file-path '("libre.org")))))
          ("l" . "Listen")
          ("ll" tags-todo "+Listen+TODO={NEXT\\|STRT}")
          ("lL" tags-todo "+Listen+TODO={NEXT\\|STRT}"
           ((org-agenda-files (org-file-path '("libre.org")))))
          ("w" . "Write")
          ("ww" tags-todo "+Write+TODO={NEXT\\|STRT}")
          ("wW" tags-todo "+Write+TODO={NEXT\\|STRT}"
           ((org-agenda-files (org-file-path '("libre.org")))))
          ("c" . "Code")
          ("cc" tags-todo "+Code+TODO={NEXT\\|STRT}")
          ("cC" tags-todo "+Code+TODO={NEXT\\|STRT}"
           ((org-agenda-files (org-file-path '("libre.org")))))
          ))
#+END_SRC

** Edit

ob-async enables asynchronous execution of org-babel src blocks, using :async

#+BEGIN_SRC emacs-lisp
  (use-package ob-async
    :config
    (require 'org))
#+END_SRC

Programming languages support

#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (shell . t)
     (org . t)
     (scheme . t)
     (python . t)
     (dot . t)
     (gnuplot . t)
     (C . t)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq org-babel-default-header-args
        '((:session . "none")
          (:results . "replace")
          (:exports . "code")
          (:cache . "no")
          (:noweb . "yes")
          (:hlines . "no")
          (:tangle . "no")
          (:padnewline . "yes")))
#+END_SRC

Don't ask before evaluating code blocks.

#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

Associate the "dot" language with the =graphviz-dot= major mode.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
#+END_SRC

Quickly insert a block of elisp:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" . "src emacs-lisp"))
#+END_SRC

Hook to update all blocks before saving

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
            (lambda() (add-hook 'before-save-hook
                                'org-update-all-dblocks t t)))
  (setq org-insert-heading-respect-content t)
  (setq org-id-method 'uuidgen)
  (setq org-id-uuid-program "uuidgen")
  (setq org-use-speed-commands
        (lambda nil
          (and (looking-at org-outline-regexp-bol)
               (not (org-in-src-block-p t)))))
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
  (setq org-link-display-descriptive nil)
  (setq org-loop-over-headlines-in-active-region t)
  ;; (setq org-create-formula-image-program 'dvipng) ;; imagemagick
  (setq org-blank-before-new-entry '((heading . t) (plain-list-item . auto)))
  (setq org-fontify-whole-heading-line t)
  (setq org-global-properties '(("Effort_ALL" . "0:10 0:30 1:00 2:00 3:30 7:00")))
  (setq org-confirm-elisp-link-function nil)
  (setq org-confirm-shell-link-function nil)
#+END_SRC

*** LaTex
Automatically parse the file after loading it.

#+BEGIN_SRC emacs-lisp
  (setq TeX-parse-self t)
#+END_SRC

Always use =pdflatex= when compiling LaTeX documents. I don't really have any
use for DVIs.

#+BEGIN_SRC emacs-lisp
  (setq TeX-PDF-mode t)
#+END_SRC

Open compiled PDFs in =evince= instead of in the editor.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
            '(lambda ()
               (delete '("\\.pdf\\'" . default) org-file-apps)
               (add-to-list 'org-file-apps '("\\.pdf\\'" . "evince %s"))))
#+END_SRC

Enable a minor mode for dealing with math (it adds a few useful keybindings),
and always treat the current file as the "main" file. That's intentional, since
I'm usually actually in an org document.

#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (LaTeX-math-mode)
              (setq TeX-master t)))
#+END_SRC

** Exporting

Translate regular ol' straight quotes to typographically-correct curly quotes
when exporting.

#+BEGIN_SRC emacs-lisp
  (setq org-export-with-smart-quotes t)
  (setq org-export-default-language "en")
  (setq org-export-backends '(latex odt icalendar html ascii))
  (setq org-export-with-archived-trees nil)
  (setq org-export-with-drawers '("HIDE"))
  (setq org-export-with-sub-superscripts nil)
  (setq org-export-with-tags 'not-in-toc)
  (setq org-export-with-timestamps t)
  (setq org-export-with-toc nil)
  (setq org-export-with-priority t)
  (setq org-export-dispatch-use-expert-ui t)
  (setq org-export-babel-evaluate t)
  (setq org-export-allow-bind-keywords t)
  (setq org-publish-list-skipped-files nil)
  (setq org-fast-tag-selection-single-key 'expert)
  (setq org-fontify-done-headline t)
  (setq org-footnote-auto-label 'confirm)
  (setq org-footnote-auto-adjust t)
  (setq org-hide-emphasis-markers t)
  (setq org-hide-macro-markers t)
  (setq org-icalendar-include-todo 'all)
  (setq org-link-frame-setup '((gnus . gnus) (file . find-file-other-window)))
  (setq org-log-note-headings
        '((done . "CLOSING NOTE %t") (state . "State %-12s %t") (clock-out . "")))
  (setq org-footnote-section "Notes")
  (setq org-attach-directory "~/.Org/data/")
  (setq org-link-display-descriptive nil)
  (setq org-export-filter-planning-functions
        '(my/org-html-export-planning))
  (setq org-export-with-broken-links t)
#+END_SRC

*** Exporting to HTML

Don't include a footer with my contact and publishing information at the bottom
of every exported HTML document.

#+BEGIN_SRC emacs-lisp
  (setq org-html-head "")
  (setq org-html-head-include-default-style nil)
  (setq org-html-postamble nil)
  (setq org-html-table-row-tags
        (cons '(cond (top-row-p "<tr class=\"tr-top\">")
                     (bottom-row-p "<tr class=\"tr-bottom\">")
                     (t (if (= (mod row-number 2) 1)
                            "<tr class=\"tr-odd\">"
                          "<tr class=\"tr-even\">")))
              "</tr>"))
  (setq org-gnus-prefer-web-links nil)
  (setq org-html-head-include-default-style nil)
  (setq org-html-head-include-scripts nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun my/org-html-export-planning (planning-string backend info)
    (when (string-match "<p>.+><\\([0-9]+-[0-9]+-[0-9]+\\)[^>]+><.+</p>" planning-string)
      (concat "<span class=\"planning\">" (match-string 1 planning-string) "</span>")))
#+END_SRC

Exporting to HTML and opening the results triggers =/usr/bin/sensible-browser=,
which checks the =$BROWSER= environment variable to choose the right browser.
I'd like to always use Firefox, so:

#+BEGIN_SRC emacs-lisp
  (setenv "BROWSER" "safari")
#+END_SRC

*** Exporting to PDF

I want to produce PDFs with syntax highlighting in the code. The best way to do
that seems to be with the =minted= package, but that package shells out to
=pygments= to do the actual work. =pdflatex= usually disallows shell commands;
this enables that.

#+BEGIN_SRC emcs-lisp
  (setq org-latex-listings t)
  (add-to-list 'org-latex-classes
	       '("my-letter"
		 "\\documentclass\{scrlttr2\}
	      \\usepackage[english,frenchb]{babel}
	      \[NO-DEFAULT-PACKAGES]
	      \[NO-PACKAGES]
	      \[EXTRA]"))
#+END_SRC


#+BEGIN_SRC emacs-lisp
  (setq org-latex-pdf-process
        '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

Include the =minted= package in all of my LaTeX exports.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-latex-listings 'minted)
#+END_SRC

** COMMENT org-mobile

#+BEGIN_SRC emacs-lisp
  (setq org-mobile-directory )
#+END_SRC

** COMMENT org-roam

Org-roam is a plain-text knowledge management system. It brings some of Roam's
more powerful features into the Org-mode ecosystem.

#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :custom
    (org-roam-directory (file-truename "~/.Org/org-roam"))
    :bind (("C-c n l" . org-roam-buffer-toggle)
           ("C-c n f" . org-roam-node-find)
           ("C-c n g" . org-roam-graph)
           ("C-c n i" . org-roam-node-insert)
           ("C-c n c" . org-roam-capture)
           ;; Dailies
           ("C-c n j" . org-roam-dailies-capture-today))
    :config
    ;; If you're using a vertical completion framework, you might want a more informative completion interface
    (setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
    (org-roam-db-autosync-mode)
    ;; If using org-roam-protocol
    (require 'org-roam-protocol))
#+end_src

** COMMENT org-brain

org-brain implements a variant of concept mapping in Emacs, using org-mode. It
is heavily inspired by a piece of software called The Brain, and you can view an
introduction to that program here. They also provide a blog with great ideas of
how you can think when organizing your Brain.

#+begin_src emacs-lisp
  (use-package org-brain
    :init
    (setq org-brain-path "~/.Org/org-brain")
    ;; For Evil users
    (with-eval-after-load 'evil
      (evil-set-initial-state 'org-brain-visualize-mode 'emacs))
    :config
    (bind-key "C-c b" 'org-brain-prefix-map org-mode-map)
    (setq org-id-track-globally t)
    (setq org-id-locations-file "~/.emacs.d/.org-id-locations")
    (add-hook 'before-save-hook #'org-brain-ensure-ids-in-buffer)
    (push '("b" "Brain" plain (function org-brain-goto-end)
            "* %i%?" :empty-lines 1)
          org-capture-templates)
    (setq org-brain-visualize-default-choices 'all)
    (setq org-brain-title-max-length 12)
    (setq org-brain-include-file-entries nil
          org-brain-file-entries-use-title nil))

  ;; Allows you to edit entries directly from org-brain-visualize
  (use-package polymode
    :config
    (add-hook 'org-brain-visualize-mode-hook #'org-brain-polymode))
#+end_src

* Writing thesis

Write raw LaTex document using [[https://www.gnu.org/software/auctex/][auctex]]

#+BEGIN_SRC emacs-lisp
  (use-package tex
    :ensure auctex
    :custom
    (TeX-engine 'xetex)
    :config
    (setq TeX-auto-save t)
    (setq TeX-parse-self t)
    (setq-default TeX-master nil)
    (add-hook 'LaTeX-mode-hook 'visual-line-mode)
    (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
    (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
    (setq reftex-plug-into-AUCTeX t))
#+END_SRC

** Set some usefull commands of latex
** Enable forward and inverse search

#+BEGIN_SRC emacs-lisp
  (setq TeX-source-correlate-method (quote synctex))
  (setq TeX-source-correlate-mode t)
  (setq TeX-source-correlate-start-server t)
#+END_SRC

** Set pdf viewer

#+BEGIN_SRC emacs-lisp
  (setq TeX-view-program-selection  '((output-pdf "PDF Viewer")))
  (setq TeX-view-program-list
        '(("PDF Viewer" "/Applications/Skim.app/Contents/SharedSupport/displayline -b -g %n %o %b")))
#+END_SRC

** Set [[https://www.gnu.org/software/auctex/reftex.html][reftex]]  References, labels, citations

#+BEGIN_SRC emacs-lisp
  ;;   (use-package org-ref)
  (add-hook 'LaTeX-mode-hook 'turn-on-reftex) ; with Auctex Latex mode
  (add-hook 'latex-mode-hook 'turn-on-reftex) ; with Emacs latex mode
  (setq reftex-plug-into-AUCTeX t)
#+END_SRC

* Writing prose

I write prose in several modes: I might be editing an Org document, or a commit
message, or an email. These are the main ones, with sub-items being /derived/
from their parents:

- =git-commit-mode=
- =text-mode=
  - =markdown-mode=
    - =gfm-mode=
  - =message-mode=
    - =mu4e-compose-mode=
  - =org-mode=

Recall that derived modes "inherit" their parent's hooks, so a hook added onto
e.g. =text-mode= will also be executed by =mu4e-compose-mode=.

There are some exceptions, but I can usually associate a hook with every
prose-related mode, so I store those in a list:

#+begin_src emacs-lisp
  (defvar prose-modes
    '(gfm-mode
      git-commit-mode
      org-mode
      markdown-mode
      message-mode
      text-mode))

  (defvar prose-mode-hooks
    (mapcar (lambda (mode) (intern (format "%s-hook" mode)))
            prose-modes))
#+end_src

** Enable spell-checking in the usual places

I want to make sure that I've enabled spell-checking if I'm editing text,
composing an email, or authoring a Git commit.

*** flyspell

https://github.com/accelbread/dotfiles/blob/a6061976a51c3335543c02d0aef3e222509e2a59/emacs/init.el#L295
#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :if (eq system-type 'darwin)
    :config
    ;; (use-package flyspell-lazy)
    ;; (flyspell-lazy-mode 1)
    :config
    (setq ispell-dictionary "en_US"
          ispell-program-name "aspell"
          ispell-extra-args '("--camel-case" "--sug-mode=ultra")
          flyspell-issue-message-flag nil
          flyspell-mode-line-string nil
          flyspell-duplicate-distance 0)

    (add-to-list 'flyspell-delayed-commands 'scroll-down-command)
    (add-to-list 'flyspell-delayed-commands 'scroll-up-command)
    (add-to-list 'flyspell-delayed-commands 'previous-line)
    (add-to-list 'flyspell-delayed-commands 'next-line)
    (add-to-list 'flyspell-delayed-commands 'line-move)
    (add-to-list 'flyspell-delayed-commands 'compilation-read-command)
    (add-to-list 'flyspell-delayed-commands 'completion-at-point-functions)

    :hook
    (prog-mode . (lambda ()
                   (unless (derived-mode-p 'json-ts-mode)
                     (flyspell-prog-mode))))
    (text-mode . flyspell-mode))
#+END_SRC

*** jinx

Jinx is a fast just-in-time spell-checker for Emacs. Jinx highlights misspelled
words in the text of the visible portion of the buffer.

#+begin_src emacs-lisp
  (use-package jinx
    :if (eq system-type 'gnu/linux)
    :hook (emacs-startup . global-jinx-mode)
    :config
    ;; (length (jinx--get-overlays (point-min) (point-max) nil))
    ;; (length (jinx--get-overlays (point-min) (point-max) t))
    ;; (length (jinx--force-overlays (point-min) (point-max) :check t))
    (setq jinx-camel-modes
          (append jinx-camel-modes
                  '(cc-ts-mode c-mode c-or-c++-mode c++-mode c++-ts-mode c-ts-mode)))

    (defun jinx--mode-line-format ()
      "updata the spelling check error informatin."
      (format "J{%d}" (length (jinx--get-overlays (window-start) (window-end) nil))))

    (add-to-list 'mode-line-misc-info
                 '(jinx-mode
                   (:eval (jinx--mode-line-format))) t)

    :bind (:map jinx-mode-map
                ("M-$" . jinx-correct)
                ("C-M-c" . jinx-correct)
                ("C-M-p" . jinx-previous)
                ("C-M-n" . jinx-next)))
#+end_src

*** define-word

A minimalists' Emacs extension to search http://www.bing.com/dict. Support
English to Chinese and Chinese to English.

#+begin_src emacs-lisp
  (use-package bing-dict
    :config
    ;; from fanyi.el
    (defun bing-dict-dwim ()
      "A more dwim version of `bing-dict'.
  No prompt if the region is active or `thing-at-point' returns
  non-nil."
      (interactive)
      (if-let ((word (if (use-region-p)
                         (buffer-substring-no-properties (region-beginning) (region-end))
                       (thing-at-point 'word t))))
          (progn
            (bing-dict-brief word))
        (call-interactively #'bing-dict-brief)))
    :bind ("C-c d" . 'bing-dict-dwim))
#+end_src

fanyi.el is a simple yet powerful multi-dictionaries interface for Emacs,
currently it includes:
海词
有道同义词, Unofficial API
etymonline
Longman.

#+begin_src emacs-lisp
  (use-package fanyi
    :config
    :bind ("C-c D" . 'fanyi-dwim2))
#+end_src

** Wrap paragraphs automatically

=AutoFillMode= automatically wraps paragraphs, kinda like hitting =M-q=. I wrap
a lot of paragraphs, so this automatically wraps 'em when I'm writing text,
Markdown, or Org.

#+begin_src emacs-lisp
  (dolist (hook prose-mode-hooks)
    (add-hook hook 'turn-on-auto-fill))
#+end_src

** Use Org-style lists and tables everywhere

Enable Org-style tables.

#+begin_src emacs-lisp
  (add-hook 'git-commit-mode-hook 'orgtbl-mode)
  (add-hook 'markdown-mode-hook 'orgtbl-mode)
  (add-hook 'message-mode-hook 'orgtbl-mode)
#+end_src

Use the [[https://elpa.gnu.org/packages/orgalist.html][=orgalist=]] package for more convenient list manipulation.

#+begin_src emacs-lisp
  (use-package orgalist
    :config
    (add-hook 'git-commit-mode-hook 'orgalist-mode)
    (add-hook 'markdown-mode-hook 'orgalist-mode)
    (add-hook 'message-mode-hook 'orgalist-mode))
#+end_src

** Editing with Markdown

Because I can't always use =org=.

- Associate =.md= files with GitHub-flavored Markdown.
- Use =pandoc= to render the results.
- Leave the code block font unchanged.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :commands gfm-mode
    :mode (("\\.md$" . gfm-mode))
    :config
    (setq markdown-command "pandoc --standalone --mathjax --from=markdown"
          markdown-fontify-code-blocks-natively t))
#+end_src

** Cycle between spacing alternatives

Successive calls to =cycle-spacing= rotate between changing the whitespace
around point to:

- A single space,
- No spaces, or
- The original spacing.

Binding this to =M-SPC= is strictly better than the original binding of
=just-one-space=.

#+begin_src emacs-lisp
  (global-set-key (kbd "M-SPC") 'cycle-spacing)
#+end_src

** Enable region case modification

#+begin_src emacs-lisp
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+end_src

** Quickly explore my "notes" directory with =deft=

#+begin_src emacs-lisp
  (use-package deft
    :bind ("C-c n" . deft)
    :commands (deft)
    :config

    (setq deft-directory "~/.notes"
          deft-recursive t
          deft-use-filename-as-title t))
#+end_src

* Editing settings
** Scroll Hydra

Scroll preserve screen position or not.
#+begin_src emacs-lisp
  (setq scroll-preserve-screen-position t)
  (defhydra hydra-scroll ()
    "move"
    ;; scroll preserve t
    ("n" scroll-up-line)
    ("p" scroll-down-line)
    ;; scroll preserve always
    ("N" (progn
           (next-line)
           (scroll-up-line)))
    ("P" (progn
           (previous-line)
           (scroll-down-line)))
    ("v" scroll-up-command)
    ("V" scroll-down-command)
    ("q" nil "quit"))
  (global-set-key (kbd "C-c b") #'hydra-scroll/body)
#+end_src

** Quickly visit Emacs
configuration

I futz around with my dotfiles a lot. This binds =C-c f= to quickly open my
Emacs configuration file.

#+BEGIN_SRC emacs-lisp
  (defun my/visit-emacs-config ()
    (interactive)
    (find-file "~/.emacs.d/configuration.org"))

  (global-set-key (kbd "C-c f") 'my/visit-emacs-config)
#+END_SRC

** Always kill current buffer

Assume that I always want to kill the current buffer when hitting =C-x k=.

#+BEGIN_SRC emacs-lisp
  (defun my/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))
  (global-set-key (kbd "C-x k") 'my/kill-current-buffer)
#+END_SRC

** Set up =helpful=

The =helpful= package provides, among other things, more context in Help
buffers.

#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :bind
    (("C-h f" . helpful-callable)
     ("C-h v" . helpful-variable)
     ("C-h k" . helpful-key)))
#+END_SRC

** Always indent with spaces

Never use tabs. Tabs are the devil’s whitespace.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

** Install and configure which-key

which-key displays the possible completions for a long keybinding. That’s really helpful
for some modes (like project, for example).

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config (which-key-mode))
#+END_SRC

** COMMENT Configure yasnippet

I keep my snippets in =~/.emacs/snippets/text-mode=, and I always want =yasnippet=
enabled.

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :config
    (use-package yasnippet-snippets)
    (yas-global-mode 1))
#+END_SRC

I /don’t/ want =ido= to automatically indent the snippets it inserts. Sometimes
this looks pretty bad (when indenting org-mode, for example, or trying to guess
at the correct indentation for Python).

#+BEGIN_SRC emacs-lisp
  (setq yas/indent-line nil)
#+END_SRC

** marginalia + consult + embark

#+begin_src emacs-lisp
  ;; A few more useful configurations...
  (use-package emacs
    :init
    (fido-vertical-mode t)
    ;; set completion case insensitive
    (setq completion-auto-help nil)
    (setq completion-ignore-case t)
    (setq read-file-name-completion-ignore-case t)
    (setq read-buffer-completion-ignore-case t)
    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
    ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
    (setq read-extended-command-predicate
          #'command-completion-default-include-p))
#+end_src


#+begin_src emacs-lisp
  (use-package icomplete
    :config
    (defun fussy-fido-setup ()
      "Use `fussy' with `fido-mode'."
      (setq-local completion-styles '(fussy)))
    (advice-add 'icomplete--fido-mode-setup :after 'fussy-fido-setup)
    (add-to-list 'completion-ignored-extensions "../")
    ;; :bind
    ;; (:map icomplete-minibuffer-map
    ;; ("TAB" . icomplete-force-complete)
    ;; ([tab] . icomplete-force-complete))
    :custom
    (icomplete-tidy-shadowed-file-names t)
    (icomplete-show-matches-on-no-input t)
    (icomplete-compute-delay 0)
    (icomplete-delay-completions-threshold 50))
#+end_src

#+begin_src emacs-lisp
  (defun my/quit-all ()
      (interactive)
      (if (eq last-command 'my/quit-all)
           (cond ((region-active-p)
                  (deactivate-mark))
                 ((> (minibuffer-depth) 0)
                  (abort-recursive-edit))
                 (current-prefix-arg
                  nil)
                 ((> (recursion-depth) 0)
                  (exit-recursive-edit))
                 (buffer-quit-function
                  (funcall buffer-quit-function)))
          (keyboard-quit)))
  (setq enable-recursive-minibuffers t)
  (global-set-key (kbd "C-g") 'my/quit-all)
#+end_src

*** fussy

#+begin_src emacs-lisp
  (if (eq system-type 'darwin)
      (setq fuz-core-bin "/usr/local/lib/libfuz_core.dylib")
    (setq fuz-core-bin "/usr/local/lib/libfuz_core.so"))
  (use-package fussy
    :config
    (when (file-exists-p fuz-core-bin)
      (use-package fuz
        :config
        (load fuz-core-bin nil t))
      (setq fussy-score-fn 'fussy-fuz-score))
    :custom
    (fussy-use-cache nil)
    (fussy-compare-same-score-fn 'fussy-histlen->strlen<)
    (fussy-filter-fn 'fussy-filter-default)
    (fussy-default-regex-fn 'fussy-pattern-flex-1)
    (completion-styles '(fussy))
    (completion-category-defaults nil)
    (completion-category-overrides nil))
#+end_src

#+begin_src emacs-lisp
  ;; For cache functionality.
  (advice-add 'corfu--capf-wrapper :before 'fussy-wipe-cache)

  (add-hook 'corfu-mode-hook
            (lambda ()
              (setq-local fussy-max-candidate-limit 5000
                          fussy-default-regex-fn 'fussy-pattern-first-letter
                          fussy-prefer-prefix nil)))
#+end_src

*** marginalia

Marginalia are marks or annotations placed at the margin of the page of a book
or in this case helpful colorful annotations placed at the margin of the
minibuffer for your completion candidates.

#+begin_src emacs-lisp
  (use-package marginalia
    :init
    ;; Must be in the :init section of use-package such that the mode gets
    ;; enabled right away. Note that this forces loading the package.
    (marginalia-mode))
#+end_src

*** consult

This package provides various commands based on the Emacs completion function
completing-read, in particular a more advanced buffer switching command
consult-buffer and a Swiper-like search command consult-line.

#+begin_src emacs-lisp
  (use-package consult
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings (mode-specific-map)
           ("C-c k" . consult-kmacro)
           ;; C-x bindings (ctl-x-map)
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ("<help> a" . consult-apropos)            ;; orig. apropos-command
           ;; M-g bindings (goto-map)
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings (search-map)
           ("M-s d" . consult-find)
           ("M-s D" . consult-locate)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s m" . consult-multi-occur)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi))           ;; needed by consult-line to detect isearch

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI. You may want to also
    ;; enable `consult-preview-at-point-mode` in Embark Collect buffers.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Optionally replace `completing-read-multiple' with an enhanced version.
    (advice-add #'completing-read-multiple :override #'consult-completing-read-multiple)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)
    :config
    (consult-customize
     consult-theme
     :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-recent-file
     consult--source-project-recent-file
     :preview-key '(:debounce 0.4 any))

    (setq consult-narrow-key "<") ;; (kbd "C-+")
    )
#+end_src

*** embark

#+begin_src emacs-lisp
  (defun my/scp-file (arg input1)
    ;; Copy files to My local device.
    (interactive "P\nsInput 1:")
    (let* ((device (completing-read "Select: " '("Mac" "EVB")))
           (cmd (format "rsync -rlt %s %s:~/man.lu.huawei/" input1 device))
           (cmd-out (shell-command-to-string cmd)))
      (if (equal cmd-out "")
          (message "Success: %s" cmd)
        (message "Failed: %s\n%s"cmd cmd-out))))
#+end_src

embark with ace-windows
https://karthinks.com/software/fifteen-ways-to-use-embark/

#+begin_src emacs-lisp
  (eval-when-compile
    (defmacro my/embark-ace-action (fn)
      `(defun ,(intern (concat "my/embark-ace-" (symbol-name fn))) ()
         (interactive)
         (with-demoted-errors "%s"
           (require 'ace-window)
           (let ((aw-dispatch-always t))
             (aw-switch-to-window (aw-select nil))
             (call-interactively (symbol-function ',fn)))))))
#+end_src

#+begin_src emacs-lisp
  (defun embark-which-key-indicator ()
    "An embark indicator that displays keymaps using which-key.
  The which-key help message will show the type and value of the
  current target followed by an ellipsis if there are further
  targets."
    (lambda (&optional keymap targets prefix)
      (if (null keymap)
          (which-key--hide-popup-ignore-command)
        (which-key--show-keymap
         (if (eq (plist-get (car targets) :type) 'embark-become)
             "Become"
           (format "Act on %s '%s'%s"
                   (plist-get (car targets) :type)
                   (embark--truncate-target (plist-get (car targets) :target))
                   (if (cdr targets) "…" "")))
         (if prefix
             (pcase (lookup-key keymap prefix 'accept-default)
               ((and (pred keymapp) km) km)
               (_ (key-binding prefix 'accept-default)))
           keymap)
         nil nil t (lambda (binding)
                     (not (string-suffix-p "-argument" (cdr binding))))))))

  (defun embark-hide-which-key-indicator (fn &rest args)
    "Hide the which-key indicator immediately when using the completing-read prompter."
    (which-key--hide-popup-ignore-command)
    (let ((embark-indicators
           (remq #'embark-which-key-indicator embark-indicators)))
      (apply fn args)))
#+end_src

Emacs Mini-Buffer Actions Rooted in Keymaps

#+begin_src emacs-lisp
  (use-package embark
    :config
    (define-key embark-file-map     (kbd "o") (my/embark-ace-action find-file))
    (define-key embark-buffer-map   (kbd "o") (my/embark-ace-action switch-to-buffer))
    (define-key embark-bookmark-map (kbd "o") (my/embark-ace-action bookmark-jump))
    (define-key embark-file-map  (kbd "s") 'my/scp-file)
    :bind
    ("C-h B" . embark-bindings) ;; alternative for `describe-bindings'
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    (bind-keys* ("C-;" . embark-act))
    :config
    (setq embark-indicators
          '(embark-which-key-indicator
            embark-highlight-indicator
            embark-isearch-highlight-indicator))
    (advice-add #'embark-completing-read-prompter
                :around #'embark-hide-which-key-indicator))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :after (embark consult)
    :demand t ; only necessary if you have the hook below
    ;; if you want to have consult previews as you move around an
    ;; auto-updating embark collect buffer
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

** corfu

#+begin_src emacs-lisp
  (use-package corfu
    :custom
    (corfu-auto-delay 0.1)
    (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
    (corfu-auto t)                 ;; Enable auto completion
    (global-corfu-modes '((not shell-mode) t))
    :bind
    (:map corfu-map
          ("TAB" . corfu-next)
          ([tab] . corfu-next)
          ("S-TAB" . corfu-previous)
          ([backtab] . corfu-previous))
    :init
    (global-corfu-mode))

  ;; Add extensions
  (use-package cape
    :init
    (global-corfu-mode)
    ;; Add `completion-at-point-functions', used by `completion-at-point'.
    (add-to-list 'completion-at-point-functions #'cape-file)
    (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (add-to-list 'completion-at-point-functions #'cape-history)
    (add-to-list 'completion-at-point-functions #'cape-keyword))

  ;; A few more useful configurations...
  (use-package emacs
    :init
    ;; TAB cycle if there are only few candidates
    (setq completion-cycle-threshold 3)

    ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
    ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
    (setq read-extended-command-predicate
          #'command-completion-default-include-p)

    ;; Enable indentation+completion using the TAB key.
    ;; `completion-at-point' is often bound to M-TAB.
    (setq tab-always-indent 'complete))
#+end_src

*** terminal popup

#+begin_src emacs-lisp
  (use-package corfu-terminal
    :init
    (unless (display-graphic-p)
      (corfu-terminal-mode +1))
    :custom
    (corfu-terminal-position-right-margin 1))
#+end_src

*** COMMENT show diagnose information

#+begin_src emacs-lisp
  (use-package flymake-popon
    :custom-face
    (flymake-popon ((t (:inherit corfu-default))))
    :hook
    (flymake-mode . flymake-popon-mode))
#+end_src

** crux

A Collection of Ridiculously Useful eXtensions for Emacs. crux bundles many
useful interactive commands to enhance your overall Emacs experience.

#+begin_src emacs-lisp
  (use-package crux
    :after xterm ;; xterm will redefine input-decode-map
    :bind
    (("C-x d" . crux-duplicate-current-line-or-region)
     ("C-x x r" . crux-rename-file-and-buffer)
     ("C-k" . crux-kill-and-join-forward)
     ("C-S-k" . crux-kill-whole-line)
     ("C-<S-k>" . crux-kill-whole-line)
     ("C-x M-c" . crux-capitalize-region))
    :init
    ;; 75 is the ASCII code for 'K', and 6 indicates Ctrl+Shift modifier.
    (define-key input-decode-map "\e[75;6~" [C-S-k]))
#+end_src

** Switch and rebalance windows when splitting

When splitting a window, I invariably want to switch to the new window. This
makes that automatic.

#+BEGIN_SRC emacs-lisp
  (defun my/split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun my/split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (let ((total-width (window-total-width)))
      (split-window-right (floor (* 0.6 total-width))))
    ;; (balance-windows)
    (other-window 1))

  (global-set-key (kbd "C-x 2") 'my/split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'my/split-window-right-and-switch)
#+END_SRC

** Mass editing of =grep= results

I like the idea of mass editing =grep= results the same way I can edit filenames
in =dired=. These keybindings allow me to use =C-x C-q= to start editing =grep=
results and =C-c C-c= to stop, just like in =dired=.

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'grep
    '(define-key grep-mode-map
      (kbd "C-x C-q") 'wgrep-change-to-wgrep-mode))

  (eval-after-load 'wgrep
    '(define-key grep-mode-map
      (kbd "C-c C-c") 'wgrep-finish-edit))

  (setq wgrep-auto-save-buffer t)
#+END_SRC

** Configure =wrap-region=

warp selected region with punctuate.

#+BEGIN_SRC emacs-lisp
  (use-package wrap-region
    :config
    (wrap-region-global-mode t)
    (wrap-region-add-wrappers
     '(("$" "$")
       ("/" "/" nil ruby-mode)
       ("/* " " */" "#" (java-mode javascript-mode css-mode))
       ("`" "`" nil (markdown-mode ruby-mode)))))
#+END_SRC

** Use multiple cursors

Hydra short-keys
#+begin_src emacs-lisp
  (defhydra hydra-multiple-cursors (:hint nil)
    "
     Up^^             Down^^           Miscellaneous           % 2(mc/num-cursors) cursor%s(if (> (mc/num-cursors) 1) \"s\" \"\")
    ------------------------------------------------------------------
     [_p_]   Next     [_n_]   Next     [_l_] Edit lines  [_0_] Insert numbers
     [_P_]   Skip     [_N_]   Skip     [_a_] Mark all    [_A_] Insert letters
     [_M-p_] Unmark   [_M-n_] Unmark   [_s_] Search
     [Click] Cursor at point       [_q_] Quit"
    ("l" mc/edit-lines :exit t)
    ("a" mc/mark-all-like-this :exit t)
    ("n" mc/mark-next-like-this)
    ("N" mc/skip-to-next-like-this)
    ("M-n" mc/unmark-next-like-this)
    ("p" mc/mark-previous-like-this)
    ("P" mc/skip-to-previous-like-this)
    ("M-p" mc/unmark-previous-like-this)
    ("s" mc/mark-all-in-region-regexp :exit t)
    ("0" mc/insert-numbers :exit t)
    ("A" mc/insert-letters :exit t)
    ("<mouse-1>" mc/add-cursor-on-click)
    ;; Help with click recognition in this hydra
    ("<down-mouse-1>" ignore)
    ("<drag-mouse-1>" ignore)
    ("q" nil))
#+end_src

Set multiple cursors for better marker words

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :bind
    ("C-c m" . hydra-multiple-cursors/body)
    :init
    (multiple-cursors-mode))
#+END_SRC

** Use expand region

Expand region increases the selected region by semantic units.
Just keep pressing the key until it selects what you want.

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind
    ("C-c q" . er/expand-region)
    ;; ("C-=" . mark-sexp)
    )
#+END_SRC

#+begin_src emacs-lisp
  (use-package expreg
    :bind
    ("C-=" . expreg-expand)
    ("C--" . expreg-contract))
#+end_src

** Use ace-jump

Use ace-jump-mode to quick jump to words or char

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :bind
    ("C-c j" . avy-goto-word-or-subword-1)
    ("C-'"   . avy-goto-char-timer)
    :config
    (setq avy-background t)
    (setq avy-timeout-seconds 0.3)
    (unbind-key "C-'" org-mode-map)) ;; jump in current frame
#+END_SRC

** Scrolling one line

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-S-n") "\C-u1\C-v")
  (global-set-key (kbd "C-S-p") "\C-u1\M-v")
#+END_SRC

** Use goto-last-change to jump between

#+BEGIN_SRC emacs-lisp
  (use-package goto-chg
    :config
    (bind-keys* ("C-." . goto-last-change))
    (bind-keys* ("C-," . goto-last-change-reverse)))
#+END_SRC

** windows manager

hydra-frame-window is designed from ace-window (C-x f) and
matches aw-dispatch-alist with a few extra

#+begin_src emacs-lisp
  (defhydra hydra-frame-window (:color red :hint nil)
    "
  ^Delete^                       ^Frame resize^             ^Window^                Window Size^^^^^^   ^TEXT^   ^Text^                 (__)
  _0_: delete-frame              _g_: resize-frame-right    _t_: toggle               ^ ^ _k_ ^ ^        _-_      _K_                   (oo)
  _1_: delete-other-frames       _H_: resize-frame-left     _e_: ace-swap-win         _h_ ^+^ _l_        _=_      _L_             /------\\/
  _2_: make-frame                _F_: fullscreen            ^ ^                       ^ ^ _j_ ^ ^        _+_      _J_            / |    ||
  _d_: kill-and-delete-frame     _n_: new-frame-right       _w_: ace-delete-window    _b_alance^^^^      ^ ^      ^ ^           *  /\\---/\\  ~~  C-x w ;
  "
    ("0" delete-frame :exit t)
    ("1" delete-other-frames :exit t)
    ("2" make-frame  :exit t)
    ("b" balance-windows :exit t)
    ("d" kill-and-delete-frame :exit t)
    ("e" ace-swap-window)
    ("F" toggle-frame-fullscreen)   ;; is <f11>
    ("g" resize-frame-right :exit t)
    ("H" resize-frame-left :exit t)  ;; aw-dispatch-alist uses h, I rebind here so hjkl can be used for size
    ("n" new-frame-right :exit t)
    ;; ("r" reverse-windows)
    ("t" toggle-window-spilt)
    ("w" ace-delete-window :exit t)
    ("x" delete-frame :exit t)
    ("K" text-scale-decrease)
    ("J" text-scale-increase)
    ("L" sensible-defaults/reset-text-size)
    ("+" my/increase-font-size)
    ("-" my/decrease-font-size)
    ("=" my/reset-font-size)
    ("h" shrink-window-horizontally)
    ("k" shrink-window)
    ("j" enlarge-window)
    ("l" enlarge-window-horizontally)
    ("q" nil :exit t))
#+end_src

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind
    ("M-o" . 'ace-window)
    ("C-x w" . hydra-frame-window/body)
    :config
    (setq aw-scope 'frame)   ; only the windows of the current frame
    (setq aw-background t)
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+END_SRC

** mange ephemeral windows

Popper is a minor-mode to tame the flood of ephemeral windows Emacs produces,
while still keeping them within arm’s reach.

#+begin_src emacs-lisp
  (use-package popper
    :bind (("C-<tab>" . popper-toggle)
           ("C-M-<tab>" . popper-cycle)
           ("C-M-<return>" . popper-toggle-type)
           ("C-M-k" . popper-kill-latest-popup))
    :custom
    ;; (popper-window-height 12)
    (popper-mode-line nil)
    :config
    (bind-keys* ("C-<tab>" . popper-toggle))
    (setq popper-group-function #'popper-group-by-project)
    :init
    (setq popper-reference-buffers
          '(;;("Output\\*$" . hide)
            (completion-list-mode . hide)
            occur-mode
            "^\\*socks5-proxy-.*\\*$"
            "\\*Async Shell Command\\*"
            "^\\*vterm.*\\*$"   vterm-mode   ;vterm as a popup
            "^\\*eat*.*$"  eat-mode
            "^\\*TeX Help.*\\*$"  tex-mode
            "^\\*tex-shell.*\\*$"  tex-mode
            compilation-mode))
    (popper-mode +1)
    (popper-echo-mode +1))                ; For echo area hints
#+end_src

** Handle layer file

#+BEGIN_SRC emacs-lisp
  (setq fast-but-imprecise-scrolling t)
#+END_SRC

** COMMENT suppress undo overflow

This is normal if you executed a command that made a huge change
to the buffer.  In that case, to prevent similar problems in the
future, set `undo-outer-limit' to a value that is large enough to
cover the maximum size of normal changes you expect a single
command to make, but not so large that it might exceed the
maximum memory allotted to Emacs.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'warning-suppress-types '(undo discard-info))
#+END_SRC

** too-long-lines
*** using too-long-lines-mode to discard extremely long lines

#+BEGIN_SRC emacs-lisp
  (use-package too-long-lines-mode
    ;; using use-package PATH
    :load-path "~/.emacs.d/too-long-lines-mode"
    ;; using quelpa URL
    ;; :quelpa
    ;; ((too-long-lines-mode
    ;;   :fetcher github
    ;;   :repo "rakete/too-long-lines-mode")
    ;;  :upgrade t)
    :config
    (setq too-long-lines-threshold 5000)
    (set 'too-long-lines-special-buffer-modes
         '(shell-mode ag-mode inferior-python-mode comint-mode compilation-mode))
    (too-long-lines-mode))
#+END_SRC

** jump back and forth

Hydra short-keys
#+begin_src emacs-lisp
  (defhydra hydra-back-and-forth ()
    "back-and-forth"
    ("<right>" back-button-local-forward "→")
    ("<left>" back-button-local-backward "←")
    ("<up>" back-button-global-backward "↑")
    ("<down>" back-button-global-forward "↓")
    ("q" nil "exit" :exit t))
#+end_src

 back-button offers local and global jumping

#+begin_src emacs-lisp
  (use-package back-button
    :bind (:map back-button-mode-map
                ("C-x <C-right>" . hydra-back-and-forth/back-button-local-forward)
                ("C-x <C-left>" . hydra-back-and-forth/back-button-local-backward)
                ("C-x <up>" . hydra-back-and-forth/back-button-global-backward)
                ("C-x <down>" . hydra-back-and-forth/back-button-global-forward))
    :init
    (back-button-mode 1)
    (define-key back-button-mode-map (kbd "C-x <C-left>") nil)
    (define-key back-button-mode-map (kbd "C-x <C-right>") nil)
    (define-key back-button-mode-map (kbd "C-x <left>") nil)
    (define-key back-button-mode-map (kbd "C-x <right>") nil)
    (define-key back-button-mode-map (kbd "C-x C-SPC") nil)
    (define-key back-button-mode-map (kbd "C-x SPC") nil))
#+end_src

Pcache required by persistent-soft required by back-botton, but it freeze emacs
when quit.

#+begin_src emacs-lisp
  (remove-hook 'kill-emacs-hook 'pcache-kill-emacs-hook)
#+end_src

** Ediff

I like Ediff's control panel to show in the same frame, even on
graphical environments.

#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)
#+END_SRC

Hydra ediff, more function with less key bindings
#+begin_src emacs-lisp
  (defhydra hydra-ediff (:color blue :hint nil)
    "
  ^Buffers           Files           VC                     Ediff regions
  ----------------------------------------------------------------------
  _b_uffers           _f_iles (_=_)       _r_evisions              _l_inewise
  _B_uffers (3-way)   _F_iles (3-way)                          _w_ordwise
                    _c_urrent file
  "
    ("b" ediff-buffers)
    ("B" ediff-buffers3)
    ("=" ediff-files)
    ("f" ediff-files)
    ("F" ediff-files3)
    ("c" ediff-current-file)
    ("r" ediff-revision)
    ("l" ediff-regions-linewise)
    ("w" ediff-regions-wordwise)
    ("q" nil :exit t))

  (global-set-key (kbd "C-c w") #'hydra-ediff/body)
#+end_src

** COMMENT Icicles

#+begin_src emacs-lisp
  (use-package icicles
    :quelpa
    ((icicles
      :fetcher github
      :repo "emacsmirror/icicles")
     :upgrade t)
    :config
    (icy-mode 1))
#+end_src

** =dired=

Use =c-x c-j= to enter current folder.

 These are the switches that get passed to =ls= when =dired= gets a list of
 files. We're using:

 - =l=: Use the long listing format.
 - =h=: Use human-readable sizes.
 - =v=: Sort numbers naturally.
 - =A=: Almost all. Doesn't include "=.=" or "=..=".

 #+BEGIN_SRC emacs-lisp
   (setq-default dired-listing-switches "-lhvA")
 #+END_SRC

 Hydra Dired
 till a work in progress but this has helped me navigate and use dired.
 #+begin_src emacs-lisp
   (defhydra hydra-dired (:hint nil :color pink)
     "
   _+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
   _C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
   _D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
   _R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
   _Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
   _S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
   _r_sync            ^ ^              ^ ^                ^ ^                _?_ summary
   _z_ compress-file  _A_ find regexp
   _Z_ compress       _Q_ repl regexp

   T - tag prefix
   "
     ("\\" dired-do-ispell)
     ("(" dired-hide-details-mode)
     (")" dired-omit-mode)
     ("+" dired-create-directory)
     ("=" diredp-ediff)         ;; smart diff
     ("?" dired-summary)
     ("$" diredp-hide-subdir-nomove)
     ("A" dired-do-find-regexp)
     ("C" dired-do-copy)        ;; Copy all marked files
     ("D" dired-do-delete)
     ("E" dired-mark-extension)
     ("e" dired-ediff-files)
     ("F" dired-do-find-marked-files)
     ("G" dired-do-chgrp)
     ("g" revert-buffer)        ;; read all directories again (refresh)
     ("i" dired-maybe-insert-subdir)
     ("l" dired-do-redisplay)   ;; relist the marked or singel directory
     ("M" dired-do-chmod)
     ("m" dired-mark)
     ("O" dired-display-file)
     ("o" dired-find-file-other-window)
     ("Q" dired-do-find-regexp-and-replace)
     ("R" dired-do-rename)
     ("r" dired-do-rsynch)
     ("S" dired-do-symlink)
     ("s" dired-sort-toggle-or-edit)
     ("t" dired-toggle-marks)
     ("U" dired-unmark-all-marks)
     ("u" dired-unmark)
     ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
     ("w" dired-kill-subdir)
     ("Y" dired-do-relsymlink)
     ("z" diredp-compress-this-file)
     ("Z" dired-do-compress)
     ("q" nil)
     ("C-g" nil :color blue)
     ("." nil :color blue))
 #+end_src

 Use “[” and “]” to jump out and in dired.

 #+BEGIN_SRC emacs-lisp
   (eval-after-load "dired"
     '(progn
        (define-key dired-mode-map (kbd "[") 'dired-up-directory)
        (define-key dired-mode-map (kbd "]") 'dired-view-file)
        (define-key dired-mode-map (kbd "K") 'dired-kill-subdir)
        (define-key dired-mode-map "." 'hydra-dired/body)))
   (eval-after-load "view"
     '(define-key view-mode-map (kbd "[") 'View-quit))
 #+END_SRC

 fast copy and past

 #+BEGIN_SRC emacs-lisp
   (setq dired-dwim-target t)
 #+END_SRC

 Kill buffers of files/directories that are deleted in =dired=.

 #+BEGIN_SRC emacs-lisp
   (setq dired-clean-up-buffers-too t)
 #+END_SRC

 Always copy directories recursively instead of asking every time.

 #+BEGIN_SRC emacs-lisp
   (setq dired-recursive-copies 'always)
 #+END_SRC

 Ask before recursively /deleting/ a directory, though.

 #+BEGIN_SRC emacs-lisp
   (setq dired-recursive-deletes 'top)
 #+END_SRC

 Files are normally moved and copied synchronously.
 This is fine for small or local files,
 but copying a large file or moving a file across a mounted
 network drive blocks Emacs until the process is completed. Unacceptable!

 reuse dired buffer
 #+begin_src emacs-lisp
   (put 'dired-find-alternate-file 'disabled nil)
 #+end_src

 narrow dired to match filter
 #+begin_src emacs-lisp
   (use-package dired-narrow
     :bind (:map dired-mode-map
                 ("/" . dired-narrow)))
 #+end_src

 dired-rsync – asynchronous rsync from dired

 #+begin_src emacs-lisp
   (use-package dired-rsync
     :config
     (bind-key "C-c C-r" 'dired-rsync dired-mode-map))
 #+end_src

** COMMENT LanguageTool

#+begin_src emacs-lisp
  (use-package langtool
    :config
    (setq langtool-http-server-host "langtool-server"
          langtool-http-server-port 8010)
    (setq langtool-default-language "en-US"))
#+end_src

** easy-kill

Provide commands easy-kill and easy-mark to let users kill or mark things
easily.

#+begin_src emacs-lisp
  (use-package easy-kill
    :init
    (global-set-key [remap kill-ring-save] 'easy-kill)
    ;; :bind
    ;; ("C-=" . easy-mark)
    ;; (:map easy-kill-base-map
    ;;       ("=" . easy-kill-expand)
    ;;       ("C-=" . easy-kill-expand)
    ;;       ("q" . easy-kill-expand))
    )
#+end_src

** useful settings

https://youtu.be/51eSeqcaikM

#+begin_src emacs-lisp
  (recentf-mode 1)
  (setq history-length 25)
  (savehist-mode 1)
  (save-place-mode 1)
#+end_src

** I-search

#+begin_src emacs-lisp
  (setq-default
   ;; Match count next to the minibuffer prompt
   isearch-lazy-count t
   ;; Don't be stingy with history; default is to keep just 16 entries
   search-ring-max 100
   regexp-search-ring-max 100)
#+end_src

** MonkeyType

#+begin_src emacs-lisp
  (use-package monkeytype
    :bind (:map monkeytype-mode-map
                ("C-c C-c k" .
                 (lambda ()
                   (interactive)
                   (kill-matching-buffers "\\*fortune\\*" nil t)
                   (kill-matching-buffers "^\\*Monkeytype\\*\\(<[0-9]*>\\)?$" nil t))))
    :custom
    (monkeytype-directory "~/.emacs.d/.monkeytype")
    (fortune-program "/usr/games/fortune")
    (fortune-dir "/usr/share/games/fortunes")
    (fortune-file "/usr/share/games/fortunes/fortunes")
    (monkeytype-auto-fill t)
    (monkeytype-colored-mode-line nil)
    (monkeytype-downcase nil)
    (monkeytype-mode-line-interval-update 50)
    (monkeytype-most-mistyped-amount 10))
#+end_src

** Add Pinyin

#+begin_src emacs-lisp
  (use-package pyim
    :custom
    (default-input-method "pyim")
    (pyim-page-tooltip '(posframe popon))
    ;; (pyim-dcache-backend 'pyim-dregcache)
    (pyim-page-length 5)
    :config
    (use-package pyim-basedict)
    (pyim-basedict-enable))
#+end_src

** COMMENT fancy-narrow

#+begin_src emacs-lisp
  (use-package fancy-narrow
    :config
    (fancy-narrow-mode))
#+end_src

** performance tuning

#+begin_src emacs-lisp
  (setq gc-cons-threshold 100000000)
  (setq read-process-output-max (* 8 1024 1024)) ;; 8mb
#+end_src

** Persistent Prefix Keymaps

https://karthinks.com/software/persistent-prefix-keymaps-in-emacs/

#+begin_src emacs-lisp
  (use-package repeat-help
    :hook (repeat-mode . repeat-help-mode))
#+end_src

* Set custom keybindings

Just a few handy functions.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-/") 'hippie-expand)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq ns-right-option-modifier 'super)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (global-unset-key (kbd "C-x 5 1"))
  (local-unset-key (kbd "C-x 5 1"))
#+END_SRC

get current buffer's name
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c o")
                  (lambda () (interactive)
                    (message buffer-file-name)
                    (kill-new buffer-file-name)))
#+END_SRC
